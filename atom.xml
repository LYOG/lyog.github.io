<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>盒子的想当然</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liuyong.cc/"/>
  <updated>2021-03-28T13:03:05.732Z</updated>
  <id>https://liuyong.cc/</id>
  
  <author>
    <name>盒子</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据一致性基础理论梳理</title>
    <link href="https://liuyong.cc/post/d042904b.html"/>
    <id>https://liuyong.cc/post/d042904b.html</id>
    <published>2019-03-17T22:55:58.000Z</published>
    <updated>2021-03-28T13:03:05.732Z</updated>
    
    <content type="html"><![CDATA[<p>趁着周末时间，把数据一致性的基础理论从头到尾梳理了一遍，真爽。</p><p>下面思维导图献上：</p><a id="more"></a><p><img src="https://lyog.cn/wp-content/uploads/2019/05/80854ce7ly1g166lvqxcfj24dk7s1e84.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;趁着周末时间，把数据一致性的基础理论从头到尾梳理了一遍，真爽。&lt;/p&gt;
&lt;p&gt;下面思维导图献上：&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>MySQL数据库如何支持emoji表情</title>
    <link href="https://liuyong.cc/post/44e620e3.html"/>
    <id>https://liuyong.cc/post/44e620e3.html</id>
    <published>2019-01-01T11:14:55.000Z</published>
    <updated>2021-03-28T13:03:05.732Z</updated>
    
    <content type="html"><![CDATA[<p>最近做的一个微信公众号的项目，有一个需求是：通过openID获取到的用户基础信息并持久化到数据库中，当时也没有多想，哐哐哐就是一通写。后来测试反馈说有些用户信息无法存储，我查了一下日志，发现类似异常：<code>java.sql.SQLException: Incorrect string value: &#39;\xF0\x9F\x92\x94&#39; for column &#39;name&#39; at row 1</code>，这才发现自己忽略了一种情况，有些用户的昵称带有emoji表情，MySQL字符集使用的uft8，只能存储3个字节的数据，但是emoji表情是4个字节，这样数据持久化的时候就必然异常。</p><a id="more"></a> <p>解决方案也比较简单，把字符集utf8更改为utf8mb4。下面是具体的步骤：</p><ol><li><p>修改字段的字符集：<code>ALTER TABLE userinfo MODIFY COLUMN nickname varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;</code></p></li><li><p>修改表的字符集：<code>ALTER TABLE userinfo charset=utf8mb4;</code></p></li><li><p>修改库的字符集：<code>SET NAMES utf8mb4;</code></p></li><li><p>项目中的MySQL配置需要修改一下，我这里用的是Spring boot，所以在<code>application.yml</code>文件中添加:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">    <span class="attr">hikari:</span></span><br><span class="line">      <span class="attr">connection-init-sql:</span> <span class="string">SET</span> <span class="string">NAMES</span> <span class="string">utf8mb4</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近做的一个微信公众号的项目，有一个需求是：通过openID获取到的用户基础信息并持久化到数据库中，当时也没有多想，哐哐哐就是一通写。后来测试反馈说有些用户信息无法存储，我查了一下日志，发现类似异常：&lt;code&gt;java.sql.SQLException: Incorrect string value: &amp;#39;\xF0\x9F\x92\x94&amp;#39; for column &amp;#39;name&amp;#39; at row 1&lt;/code&gt;，这才发现自己忽略了一种情况，有些用户的昵称带有emoji表情，MySQL字符集使用的uft8，只能存储3个字节的数据，但是emoji表情是4个字节，这样数据持久化的时候就必然异常。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>HashMap在多线程情况下还会导致死循环吗</title>
    <link href="https://liuyong.cc/post/e05a5fab.html"/>
    <id>https://liuyong.cc/post/e05a5fab.html</id>
    <published>2018-06-10T22:56:44.000Z</published>
    <updated>2021-03-28T13:03:05.732Z</updated>
    
    <content type="html"><![CDATA[<p>先放结论，这个问题出现在JDK1.7及以前版本中，而现在JDK1.8中已经解决这个问题了。</p><h4 id="JDK1-7中的死循环"><a href="#JDK1-7中的死循环" class="headerlink" title="JDK1.7中的死循环"></a>JDK1.7中的死循环</h4><p>我们知道HashMap&lt;K,V&gt;存放的数据量大于了装载因子（默认75%），那么HashMap&lt;K,V&gt;就需要进行扩容操作，扩容的空间大小就是原来空间的两倍，但是扩容的时候需要rehash操作,然后赋给新的HashMap&lt;K,V&gt;。</p><p>JDK中需要使用resize()函数进行扩容，下面时resize()的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">        <span class="keyword">boolean</span> oldAltHashing = useAltHashing;</span><br><span class="line">        useAltHashing |= sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">                (newCapacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">        <span class="keyword">boolean</span> rehash = oldAltHashing ^ useAltHashing;</span><br><span class="line">        transfer(newTable, rehash);  <span class="comment">//transfer函数的调用</span></span><br><span class="line">        table = newTable;</span><br><span class="line">        threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在resize()这个过程中,在并发情况下也是不会出现死循环的问题，关键问题是transfer函数的调用过程。</p><a id="more"></a> <p>下面时transfer()的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123; <span class="comment">//这里才是问题出现的关键..</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;  <span class="comment">//寻找到下一个节点..</span></span><br><span class="line">                <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                    e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);  <span class="comment">//重新获取hashcode</span></span><br><span class="line">                e.next = newTable[i];  </span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>while中的操作我们先简化成四个步骤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">next = e.next;</span><br><span class="line">e.next = newTable[i];</span><br><span class="line">newTable[i] = e;</span><br><span class="line">e = next;</span><br></pre></td></tr></table></figure><p>下面来抽象一下发生死循环的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程一开始执行while内的操作</span></span><br><span class="line">next = e.next;</span><br><span class="line">e.next = newTable[i];</span><br><span class="line">newTable[i] = e;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 紧接着线程二执行while内的操作</span></span><br><span class="line">next = e.next;</span><br><span class="line">e.next = newTable[i]; <span class="comment">// 经线程一操作，此时newTable[i]实际上为e</span></span><br></pre></td></tr></table></figure><p>上述情况导致e.next = e，造成一个闭环，最终形成死循环。</p><h4 id="JDK1-8中的解决方案"><a href="#JDK1-8中的解决方案" class="headerlink" title="JDK1.8中的解决方案"></a>JDK1.8中的解决方案</h4><p>在1.8中resize()方法不再调用transfer()方法，而是直接将原来transfer()方法中的代码写在自己方法体内； 同时还有一个重大改变，那就是：<strong>扩容后，新数组中的链表顺序依然与旧数组中的链表顺序保持一致！</strong> </p><p>下面是resize()方法的部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果扩容后，元素的index依然与原来一样，那么使用这个head和tail指针</span></span><br><span class="line">Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span></span><br><span class="line"><span class="comment">//如果扩容后，元素的index=index+oldCap，那么使用这个head和tail指针</span></span><br><span class="line">Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span></span><br><span class="line">Node&lt;K,V&gt; next;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    next = e.next;</span><br><span class="line">    <span class="comment">//这个地方直接通过hash值与oldCap进行与操作得出元素在新数组的index</span></span><br><span class="line">    <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">            loHead = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            loTail.next = e;  </span><br><span class="line">        loTail = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">            hiHead = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hiTail.next = e;   </span><br><span class="line">        hiTail = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>实际抽象出来只有两步：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.添加一个节点</span></span><br><span class="line"><span class="keyword">if</span> (tail == <span class="keyword">null</span>)</span><br><span class="line">    head = e;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    tail.next = e;</span><br><span class="line"><span class="comment">// 2.tail指针往后移动一位，维持顺序    </span></span><br><span class="line">tail = e;</span><br></pre></td></tr></table></figure><p>这样就可以解决死循环问题了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先放结论，这个问题出现在JDK1.7及以前版本中，而现在JDK1.8中已经解决这个问题了。&lt;/p&gt;
&lt;h4 id=&quot;JDK1-7中的死循环&quot;&gt;&lt;a href=&quot;#JDK1-7中的死循环&quot; class=&quot;headerlink&quot; title=&quot;JDK1.7中的死循环&quot;&gt;&lt;/a&gt;JDK1.7中的死循环&lt;/h4&gt;&lt;p&gt;我们知道HashMap&amp;lt;K,V&amp;gt;存放的数据量大于了装载因子（默认75%），那么HashMap&amp;lt;K,V&amp;gt;就需要进行扩容操作，扩容的空间大小就是原来空间的两倍，但是扩容的时候需要rehash操作,然后赋给新的HashMap&amp;lt;K,V&amp;gt;。&lt;/p&gt;
&lt;p&gt;JDK中需要使用resize()函数进行扩容，下面时resize()的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;resize&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; newCapacity)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Entry[] oldTable = table;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; oldCapacity = oldTable.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (oldCapacity == MAXIMUM_CAPACITY) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            threshold = Integer.MAX_VALUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Entry[] newTable = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Entry[newCapacity];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; oldAltHashing = useAltHashing;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        useAltHashing |= sun.misc.VM.isBooted() &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                (newCapacity &amp;gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; rehash = oldAltHashing ^ useAltHashing;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        transfer(newTable, rehash);  &lt;span class=&quot;comment&quot;&gt;//transfer函数的调用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        table = newTable;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        threshold = (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在resize()这个过程中,在并发情况下也是不会出现死循环的问题，关键问题是transfer函数的调用过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="https://liuyong.cc/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>为什么wait，notify和notifyall定义在Object中</title>
    <link href="https://liuyong.cc/post/92da4c91.html"/>
    <id>https://liuyong.cc/post/92da4c91.html</id>
    <published>2018-06-04T15:56:44.000Z</published>
    <updated>2021-03-28T13:03:05.732Z</updated>
    
    <content type="html"><![CDATA[<p>为什么wait，notify和notifyall定义在Object中，而不是定义在Thread类中？</p><ol><li>wait和nofity在Java中主要是实现线程之间的通信，把它们定义在Object类中，可以使任何Java对象都可以拥有实现线程通讯机制的能力。</li><li>每个对象都可以作为锁。</li><li>在Java中，为了进入临界区代码段，线程需要获得锁并且等待锁可用。它们不知道哪些线程持有锁，但是它们知道锁由哪些线程持有。它们应该等待锁而不是去查找哪个线程在代码块中去要求它们释放锁。</li></ol><a id="more"></a> ]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为什么wait，notify和notifyall定义在Object中，而不是定义在Thread类中？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;wait和nofity在Java中主要是实现线程之间的通信，把它们定义在Object类中，可以使任何Java对象都可以拥有实现线程通讯机制的能力。&lt;/li&gt;
&lt;li&gt;每个对象都可以作为锁。&lt;/li&gt;
&lt;li&gt;在Java中，为了进入临界区代码段，线程需要获得锁并且等待锁可用。它们不知道哪些线程持有锁，但是它们知道锁由哪些线程持有。它们应该等待锁而不是去查找哪个线程在代码块中去要求它们释放锁。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="https://liuyong.cc/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Cookie与Session的区别</title>
    <link href="https://liuyong.cc/post/62504291.html"/>
    <id>https://liuyong.cc/post/62504291.html</id>
    <published>2018-06-03T15:56:44.000Z</published>
    <updated>2021-03-28T13:03:05.732Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Cookie机制"><a href="#Cookie机制" class="headerlink" title="Cookie机制"></a>Cookie机制</h4><p>Cookies是服务器在本地机器上存储的小段文字并随每一个请求发送至同一个服务器。网络服务器用HTTP头向客户端发送Cookies，在客户端，浏览器解析这些Cookies并将它们保存为一个本地文件，它会自动将同一服务器的任何请求缚上这些Cookies。</p><p>具体来说Cookie机制采取的是<strong>在客户端保持状态</strong>的方案。它需要用户打开客户端的Cookie支持，它的作用就是为了<strong>解决HTTP协议无状态</strong>的缺陷。</p><p><strong>Cookie的内容主要包括：名字、值、过期时间、路径和域。</strong></p><p>路径和域一起构成Cookie的作用范围。</p><p>若不设置范围，则Cookie的生命周期为浏览器会话状态期间，关闭浏览器，Cookie就消失。这种Cookie称为会话Cookie，通常保存在内存中。而设置了过期时间的Cookie会被保存至硬盘。</p><h4 id="Session机制"><a href="#Session机制" class="headerlink" title="Session机制"></a>Session机制</h4><p>Session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构来保存信息。</p><p>当程序需要为某个客户端的请求创建一个Session时，服务器首先检查这个客户端里知否已经包含一个Session标识，如果包含则按照Session ID来把这个Session检索出来，检索不到的话会新建一个。</p><p>如果客户端请求不包含Session ID，则为此客户端创建一个Session并生成一个与此Session相关联的Session ID，这个Session ID将在本次响应中返回给客户端。</p><p>保存这个Session ID的方式可以采用Cookie，但如果Cookie被人禁止的话，就必须使用其它机制来传递Session ID。通常使用的一种技术叫做URL重写，就是把Session ID直接附加在URL路径后面；还有一种技术叫做表单隐藏字段，就是服务器会自动修改表单，添加一个隐藏字段，以便表单提交时能欧巴Session ID传回给服务器。</p><a id="more"></a> <h4 id="Cookie与Session的区别"><a href="#Cookie与Session的区别" class="headerlink" title="Cookie与Session的区别"></a>Cookie与Session的区别</h4><h5 id="存取方式不同"><a href="#存取方式不同" class="headerlink" title="存取方式不同"></a>存取方式不同</h5><p>Cookie只能保存ASCII字符串，如果需要存取Unicode字符或者二进制数据，需要先进行编码。</p><p>Cookie中也不能存取Java对象。</p><p>Session可以存取任意类型的数据，包括但不限于String、Integer、List、Map等。</p><p>Session中能够直接报关Java Bean甚至Java类、对象等，可以把Session看作一个Java容器。</p><h5 id="隐私策略不同"><a href="#隐私策略不同" class="headerlink" title="隐私策略不同"></a>隐私策略不同</h5><p>Cookie存储在客户端，对客户端是可见的，客户端可以窥探、复制和修改Cookie中的内容</p><p>Session存储在服务器中，对客户端是透明的，不存在敏感信息泄露的风险。</p><p>Cookie保护隐私的办法：敏感信息不要写进Cookie中，同时将Cookie信息加密，提交至服务器后再进行解密。</p><h5 id="有效期不同"><a href="#有效期不同" class="headerlink" title="有效期不同"></a>有效期不同</h5><p>使用Cookie，然后过期时间设置一个很大的数字，这样能实现登陆信息长期有效。比如Google，登陆一次后Google会持久的记载该用户的登陆信息，不用每次都重新登陆。</p><p>Session依赖于名为JSESSIONID的Cookie，而此Cookie的过期时间默认为-1，当浏览器关闭时该Session就会失效。而如果过期时间设置一个很大的值的时候，服务器的Session就会越堆越多，容易导致内存溢出。</p><h5 id="服务器压力不同"><a href="#服务器压力不同" class="headerlink" title="服务器压力不同"></a>服务器压力不同</h5><p>Session是保管在服务器上的，每个用户都产生一个Session，如果并发访问用户过多，则会产生很多的session消耗大量的内存。</p><p>而反观Cookie，它是保存在客户端的，不会占用服务器资源，所有并发量过大的时候，Cookie会是一个很好的选择。</p><h5 id="浏览器支持不同"><a href="#浏览器支持不同" class="headerlink" title="浏览器支持不同"></a>浏览器支持不同</h5><p>Cookie是需要客户端浏览器支持的，如果被禁用，则会话跟踪就会失效。</p><p>如果不支持Cookie，就需要使用Session，并且要保证所有用到Session的程序都有进行URL地址重写。</p><p>如果浏览器支持Cookie，则Cookie既能设置为本窗口和子窗口有效，也能设置为所有窗口有效。</p><p>但是Session只能在本窗口及子窗口下有效，如果两个浏览器窗口互不相干，则它们将运用两个不同的Session。</p><h5 id="跨域支持上的不同"><a href="#跨域支持上的不同" class="headerlink" title="跨域支持上的不同"></a>跨域支持上的不同</h5><p>Cookie支持跨域名访问，例如把domain属性设置为“.lyog.cn”，则以“.lyog.cn”为后缀的域名都能够访问该Cookie。</p><p>Session仅在它所在的域名内有效。</p><p>实际的生产过程中，不会仅仅使用一种的，而是Cookie和Session搭配使用，这样效果才会更好。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Cookie机制&quot;&gt;&lt;a href=&quot;#Cookie机制&quot; class=&quot;headerlink&quot; title=&quot;Cookie机制&quot;&gt;&lt;/a&gt;Cookie机制&lt;/h4&gt;&lt;p&gt;Cookies是服务器在本地机器上存储的小段文字并随每一个请求发送至同一个服务器。网络服务器用HTTP头向客户端发送Cookies，在客户端，浏览器解析这些Cookies并将它们保存为一个本地文件，它会自动将同一服务器的任何请求缚上这些Cookies。&lt;/p&gt;
&lt;p&gt;具体来说Cookie机制采取的是&lt;strong&gt;在客户端保持状态&lt;/strong&gt;的方案。它需要用户打开客户端的Cookie支持，它的作用就是为了&lt;strong&gt;解决HTTP协议无状态&lt;/strong&gt;的缺陷。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cookie的内容主要包括：名字、值、过期时间、路径和域。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;路径和域一起构成Cookie的作用范围。&lt;/p&gt;
&lt;p&gt;若不设置范围，则Cookie的生命周期为浏览器会话状态期间，关闭浏览器，Cookie就消失。这种Cookie称为会话Cookie，通常保存在内存中。而设置了过期时间的Cookie会被保存至硬盘。&lt;/p&gt;
&lt;h4 id=&quot;Session机制&quot;&gt;&lt;a href=&quot;#Session机制&quot; class=&quot;headerlink&quot; title=&quot;Session机制&quot;&gt;&lt;/a&gt;Session机制&lt;/h4&gt;&lt;p&gt;Session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构来保存信息。&lt;/p&gt;
&lt;p&gt;当程序需要为某个客户端的请求创建一个Session时，服务器首先检查这个客户端里知否已经包含一个Session标识，如果包含则按照Session ID来把这个Session检索出来，检索不到的话会新建一个。&lt;/p&gt;
&lt;p&gt;如果客户端请求不包含Session ID，则为此客户端创建一个Session并生成一个与此Session相关联的Session ID，这个Session ID将在本次响应中返回给客户端。&lt;/p&gt;
&lt;p&gt;保存这个Session ID的方式可以采用Cookie，但如果Cookie被人禁止的话，就必须使用其它机制来传递Session ID。通常使用的一种技术叫做URL重写，就是把Session ID直接附加在URL路径后面；还有一种技术叫做表单隐藏字段，就是服务器会自动修改表单，添加一个隐藏字段，以便表单提交时能欧巴Session ID传回给服务器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络" scheme="https://liuyong.cc/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>HTTP中Get请求与Post请求的区别</title>
    <link href="https://liuyong.cc/post/b0ac8d7a.html"/>
    <id>https://liuyong.cc/post/b0ac8d7a.html</id>
    <published>2018-06-01T15:56:44.000Z</published>
    <updated>2021-03-28T13:03:05.732Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GET和POST长度的限制问题"><a href="#GET和POST长度的限制问题" class="headerlink" title="GET和POST长度的限制问题"></a>GET和POST长度的限制问题</h3><p><strong>GET</strong></p><ul><li>GET是通过URL提交数据，因此GET可提交的数据量就跟URL所能达到的最大长度有直接关系</li><li>实际上HTTP协议对URL长度是没有限制的；限制URL长度大多数是浏览器或者服务器的配置参数</li></ul><p><strong>POST</strong></p><ul><li>HTTP协议没有对POST进行任何限制，一般是受服务器配置限制或者内存大小</li></ul><h3 id="GET和POST的安全性"><a href="#GET和POST的安全性" class="headerlink" title="GET和POST的安全性"></a>GET和POST的安全性</h3><p>GET是通过URL方式请求，可以直接看到，明文传输。 </p><p>POST是通过请求header请求，可以开发者工具或者抓包可以看到，同样也是明文的。</p><p>GET请求会保存在浏览器历史纪录中，还可能会保存在Web的日志中。</p><h3 id="GET和POST对服务器的状态"><a href="#GET和POST对服务器的状态" class="headerlink" title="GET和POST对服务器的状态"></a>GET和POST对服务器的状态</h3><p>根据http的设计，大家在看到get的时候，都期望这个请求对服务器没有修改，看到post的时候，都认为这对服务器产生了修改。 </p><a id="more"></a> <h3 id="GET和POST的幂等性"><a href="#GET和POST的幂等性" class="headerlink" title="GET和POST的幂等性"></a>GET和POST的幂等性</h3><p>幂等是指同一个请求方法执行多次和仅执行一次的效果完全相同。 <strong>GET幂等，POST不幂等</strong> 。</p><p>引入幂等主要是为了处理同一个请求重复发送的情况，比如在请求响应前失去连接，如果方法是幂等的，就可以放心地重发一次请求。这也是浏览器在后退/刷新时遇到POST会给用户提示的原因：POST语义不是幂等的，重复请求可能会带来意想不到的后果。 </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;GET和POST长度的限制问题&quot;&gt;&lt;a href=&quot;#GET和POST长度的限制问题&quot; class=&quot;headerlink&quot; title=&quot;GET和POST长度的限制问题&quot;&gt;&lt;/a&gt;GET和POST长度的限制问题&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;GET&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GET是通过URL提交数据，因此GET可提交的数据量就跟URL所能达到的最大长度有直接关系&lt;/li&gt;
&lt;li&gt;实际上HTTP协议对URL长度是没有限制的；限制URL长度大多数是浏览器或者服务器的配置参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;POST&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP协议没有对POST进行任何限制，一般是受服务器配置限制或者内存大小&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;GET和POST的安全性&quot;&gt;&lt;a href=&quot;#GET和POST的安全性&quot; class=&quot;headerlink&quot; title=&quot;GET和POST的安全性&quot;&gt;&lt;/a&gt;GET和POST的安全性&lt;/h3&gt;&lt;p&gt;GET是通过URL方式请求，可以直接看到，明文传输。 &lt;/p&gt;
&lt;p&gt;POST是通过请求header请求，可以开发者工具或者抓包可以看到，同样也是明文的。&lt;/p&gt;
&lt;p&gt;GET请求会保存在浏览器历史纪录中，还可能会保存在Web的日志中。&lt;/p&gt;
&lt;h3 id=&quot;GET和POST对服务器的状态&quot;&gt;&lt;a href=&quot;#GET和POST对服务器的状态&quot; class=&quot;headerlink&quot; title=&quot;GET和POST对服务器的状态&quot;&gt;&lt;/a&gt;GET和POST对服务器的状态&lt;/h3&gt;&lt;p&gt;根据http的设计，大家在看到get的时候，都期望这个请求对服务器没有修改，看到post的时候，都认为这对服务器产生了修改。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="网络" scheme="https://liuyong.cc/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>Java序列化与反序列化</title>
    <link href="https://liuyong.cc/post/5e5c5c3.html"/>
    <id>https://liuyong.cc/post/5e5c5c3.html</id>
    <published>2018-05-18T15:56:44.000Z</published>
    <updated>2021-03-28T13:03:05.732Z</updated>
    
    <content type="html"><![CDATA[<h3 id="序列化的作用"><a href="#序列化的作用" class="headerlink" title="序列化的作用"></a>序列化的作用</h3><p>Java平台允许我们在内存中创建可复用的Java对象，但一般情况下，只有当JVM处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比JVM的生命周期更长。但在现实应用中，就可能要求在JVM停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。Java对象序列化就能够帮助我们实现该功能。</p><p>使用Java对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装成对象。必须注意地是，对象序列化保存的是对象的”状态”，即它的成员变量。由此可知，<strong>对象序列化不会关注类中的静态变量</strong>。</p><p>除了在持久化对象时会用到对象序列化之外，当使用RMI(远程方法调用)，或在网络中传递对象时，都会用到对象序列化。</p><a id="more"></a> <h3 id="序列化与反序列化的特性"><a href="#序列化与反序列化的特性" class="headerlink" title="序列化与反序列化的特性"></a>序列化与反序列化的特性</h3><ol><li>在Java中，只要一个类实现了<code>java.io.Serializable</code>接口，那么它就可以被序列化。 </li><li>通过<code>ObjectOutputStream</code>和<code>ObjectInputStream</code>对对象进行序列化及反序列化。</li><li>虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 <code>private static final long serialVersionUID</code>）。</li><li>序列化并不保存静态变量。 </li><li>要想将父类对象也序列化，就需要让父类也实现<code>Serializable</code> 接口。 </li><li>Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。 </li><li>服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。  </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;序列化的作用&quot;&gt;&lt;a href=&quot;#序列化的作用&quot; class=&quot;headerlink&quot; title=&quot;序列化的作用&quot;&gt;&lt;/a&gt;序列化的作用&lt;/h3&gt;&lt;p&gt;Java平台允许我们在内存中创建可复用的Java对象，但一般情况下，只有当JVM处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比JVM的生命周期更长。但在现实应用中，就可能要求在JVM停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。Java对象序列化就能够帮助我们实现该功能。&lt;/p&gt;
&lt;p&gt;使用Java对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装成对象。必须注意地是，对象序列化保存的是对象的”状态”，即它的成员变量。由此可知，&lt;strong&gt;对象序列化不会关注类中的静态变量&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;除了在持久化对象时会用到对象序列化之外，当使用RMI(远程方法调用)，或在网络中传递对象时，都会用到对象序列化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="https://liuyong.cc/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>equals与hashCode方法的联系</title>
    <link href="https://liuyong.cc/post/d2ef011b.html"/>
    <id>https://liuyong.cc/post/d2ef011b.html</id>
    <published>2018-05-08T15:56:44.000Z</published>
    <updated>2021-03-28T13:03:05.732Z</updated>
    
    <content type="html"><![CDATA[<h3 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h3><p>equals()是用来判断其他的对象是否和该对象相等。</p><p>equals()在object类中定义如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显是两个对象的地址值的比较。通常封装类有用到这个equals()时，都会对它进行重写。</p><p>它具有以下性质：</p><ul><li>自反性：对任意不为null的引用值x，x.equals(x)一定为true</li><li>对称性：对任意不为null的引用值x和y，当x.equals(y)为true时，y.equals(x)也为true</li><li>传递性：对任意不为null的引用值x、y、z，当x.equals(y)为true，并且y.equals(z)也为true时，x.equals(z)也为true</li><li>一致性：对任意不为null的引用值x和y，在对象信息没有被改的情况下，多次调用x.equals(y)结果不变</li></ul><p><strong>当equals()方法被override时，hashCode()也要被override，因为相等的对象，hashCode一定相等。</strong></p><a id="more"></a> <h3 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h3><p>hashCode()会给对象返回一个hashCode值。</p><p>它的性质：</p><ul><li>在一个Java应用的执行期间，如果一个对象提供给equals做比较的信息没有被修改的话，该对象多次调用hashCode方法，该方法必须始终如一返回同一个Integer。</li><li>如果两个对象根据equals方法是相等的，那么调用二者各自的hashCode方法必须产生同一个Integer结果。</li><li>并不要求根据equals(java.lang.Object)方法不相等的两个对象，调用二者各自的hashCode方法必须产生不同的integer结果。 </li></ul><h3 id="hashCode方法和equals方法的联系"><a href="#hashCode方法和equals方法的联系" class="headerlink" title="hashCode方法和equals方法的联系"></a>hashCode方法和equals方法的联系</h3><p>如何判断元素是否在HashSet中重复，过程如下：</p><ol><li>判断两个对象hashCode是否相等<ul><li>如果不相等，则认为两个对象也不相等</li><li>如果相等，进行下一步，判断equals是否相等</li></ul></li><li>判断两个对象equals运算是否相等<ul><li>如果不相等，两个对象不相等</li><li>如果相等，两个对象相等</li></ul></li></ol><p><strong>步骤一的作用主要是为了提高存储效率。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;equals方法&quot;&gt;&lt;a href=&quot;#equals方法&quot; class=&quot;headerlink&quot; title=&quot;equals方法&quot;&gt;&lt;/a&gt;equals方法&lt;/h3&gt;&lt;p&gt;equals()是用来判断其他的对象是否和该对象相等。&lt;/p&gt;
&lt;p&gt;equals()在object类中定义如下： &lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object obj)&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; == obj);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;很明显是两个对象的地址值的比较。通常封装类有用到这个equals()时，都会对它进行重写。&lt;/p&gt;
&lt;p&gt;它具有以下性质：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自反性：对任意不为null的引用值x，x.equals(x)一定为true&lt;/li&gt;
&lt;li&gt;对称性：对任意不为null的引用值x和y，当x.equals(y)为true时，y.equals(x)也为true&lt;/li&gt;
&lt;li&gt;传递性：对任意不为null的引用值x、y、z，当x.equals(y)为true，并且y.equals(z)也为true时，x.equals(z)也为true&lt;/li&gt;
&lt;li&gt;一致性：对任意不为null的引用值x和y，在对象信息没有被改的情况下，多次调用x.equals(y)结果不变&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;当equals()方法被override时，hashCode()也要被override，因为相等的对象，hashCode一定相等。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="https://liuyong.cc/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>二维码纠错原理</title>
    <link href="https://liuyong.cc/post/e6a9e5f4.html"/>
    <id>https://liuyong.cc/post/e6a9e5f4.html</id>
    <published>2018-05-01T23:14:44.000Z</published>
    <updated>2021-03-28T13:03:05.732Z</updated>
    
    <content type="html"><![CDATA[<p>前言：今天坐车的时候看到座位上有个被污染二维码，然后发现依然被识别，心里纳闷这二维码究竟是一个什么纠错原理？</p><h3 id="Reed-solomon-codes"><a href="#Reed-solomon-codes" class="headerlink" title="Reed-solomon codes"></a>Reed-solomon codes</h3><p>在网上搜寻一番，发现二维码通过RS码进行纠错。关于RS码，维基百科是这么定义的：</p><blockquote><p>里德-所罗门码（里所码，Reed-solomon codes，简称RS codes）是一种前向错误更正的信道编码，对由校正过采样数据所产生的有效多项式。编码过程首先在多个点上对这些多项式求冗余，然后将其传输或者存储。对多项式的这种超出必要值得采样使得多项式超定（过限定）。当接收器正确的收到足够的点后，它就可以恢复原来的多项式，即使接收到的多项式上有很多点被噪声干扰失真。</p></blockquote><p>好了，说人话：任意k个确定点可以表示一个阶数至少为k-1的多项式，比如我们只需要16个点就可以确定这个多项式，但是可以发送25个点的数据，所以我们可以在其它点对这个多项式求冗余，哪怕25个点里有几个点缺失了，也可以通过剩余的点去反推出最初的多项式。</p><a id="more"></a> <h3 id="二维码纠错能力"><a href="#二维码纠错能力" class="headerlink" title="二维码纠错能力"></a>二维码纠错能力</h3><p>二维码纠错分为四个级别：</p><ul><li>级别L：7%</li><li>级别M：15%</li><li>级别Q：25%</li><li>级别H：30%</li></ul><p>纠错能力越高，所占用的数据量越大，二维码尺寸越大。</p><p>至于纠错比例是如何计算的呢，我们举个例子：<br>例如，需要编码的码字数据有100个，并且想对其中的一半，也就是50个码字进行纠错，则计算方法如下。纠错需要相当于码字2倍的符号（RS编码），因此在这种情况下的数量为50个×2＝100码字。因此，全部码字数量为200个，其中用作纠错的码字为50个，所以计算得出，相对于全部码字的纠错率就是25%。这一比率相当于QR码纠错级别中的“Q”级别。</p><hr><p><a href="https://coolshell.cn/articles/10590.html" target="_blank" rel="noopener">《二维码的生成细节和原理》</a>是左耳朵耗子陈皓大大的文章，写的非常棒。关于二维码的生成细节可以看这篇文章，我这里就不献丑了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言：今天坐车的时候看到座位上有个被污染二维码，然后发现依然被识别，心里纳闷这二维码究竟是一个什么纠错原理？&lt;/p&gt;
&lt;h3 id=&quot;Reed-solomon-codes&quot;&gt;&lt;a href=&quot;#Reed-solomon-codes&quot; class=&quot;headerlink&quot; title=&quot;Reed-solomon codes&quot;&gt;&lt;/a&gt;Reed-solomon codes&lt;/h3&gt;&lt;p&gt;在网上搜寻一番，发现二维码通过RS码进行纠错。关于RS码，维基百科是这么定义的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;里德-所罗门码（里所码，Reed-solomon codes，简称RS codes）是一种前向错误更正的信道编码，对由校正过采样数据所产生的有效多项式。编码过程首先在多个点上对这些多项式求冗余，然后将其传输或者存储。对多项式的这种超出必要值得采样使得多项式超定（过限定）。当接收器正确的收到足够的点后，它就可以恢复原来的多项式，即使接收到的多项式上有很多点被噪声干扰失真。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好了，说人话：任意k个确定点可以表示一个阶数至少为k-1的多项式，比如我们只需要16个点就可以确定这个多项式，但是可以发送25个点的数据，所以我们可以在其它点对这个多项式求冗余，哪怕25个点里有几个点缺失了，也可以通过剩余的点去反推出最初的多项式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="一些思考" scheme="https://liuyong.cc/categories/%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>抽象类和接口的区别</title>
    <link href="https://liuyong.cc/post/3e6ff0a8.html"/>
    <id>https://liuyong.cc/post/3e6ff0a8.html</id>
    <published>2018-04-02T15:56:44.000Z</published>
    <updated>2021-03-28T13:03:05.732Z</updated>
    
    <content type="html"><![CDATA[<h3 id="抽象类（abstract-class）"><a href="#抽象类（abstract-class）" class="headerlink" title="抽象类（abstract class）"></a>抽象类（abstract class）</h3><p>定义：如果一个类没有包含足够多的信息来描述一个具体的对象，这样的类就是抽象类。 使用abstract来修饰。</p><p>特点：</p><ul><li>不能实例化 ，只能被继承</li><li>被abstract修饰的方法 ，只声明，不实现</li><li>含有含有抽象方法 的类必须为抽象类</li></ul><a id="more"></a><h3 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h3><p>定义：接口在Java中是一个抽象类型，是抽象方法的集合。 </p><p>特点：</p><ul><li>接口不是类，所以没有构造方式 </li><li>方法必须是抽象的 </li><li>除了static、final变量，不能有其他变量 </li><li>支持多继承 </li><li>实现某个接口的类必须在类中实现该接口的全部方法</li></ul><h3 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>抽象类可以有已经实现的方法，也可以有抽象方法；接口里的方法必须全部是抽象的。</p><p>抽象类的方法可以有public、protected和default这些修饰符 ；接口的方法必须是public。</p><p>抽象类比接口速度快，因为接口要去类中寻找实现。</p><h4 id="方法实现"><a href="#方法实现" class="headerlink" title="方法实现"></a>方法实现</h4><p>抽象类不能被实例化，只能被继承。同时子类必须实现父类的所有抽象方法才能被实例化，不然子类只能定义为抽象类；实现接口的类必须实现接口所有的抽象方法。</p><p>抽象类使用extends来继承，只能单继承；接口使用implements来继承，可以多继承。</p><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p>抽象类有构造器，而接口没有</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;抽象类（abstract-class）&quot;&gt;&lt;a href=&quot;#抽象类（abstract-class）&quot; class=&quot;headerlink&quot; title=&quot;抽象类（abstract class）&quot;&gt;&lt;/a&gt;抽象类（abstract class）&lt;/h3&gt;&lt;p&gt;定义：如果一个类没有包含足够多的信息来描述一个具体的对象，这样的类就是抽象类。 使用abstract来修饰。&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不能实例化 ，只能被继承&lt;/li&gt;
&lt;li&gt;被abstract修饰的方法 ，只声明，不实现&lt;/li&gt;
&lt;li&gt;含有含有抽象方法 的类必须为抽象类&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="https://liuyong.cc/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>工厂模式</title>
    <link href="https://liuyong.cc/post/54788f73.html"/>
    <id>https://liuyong.cc/post/54788f73.html</id>
    <published>2018-03-27T00:50:45.000Z</published>
    <updated>2021-03-28T13:03:05.732Z</updated>
    
    <content type="html"><![CDATA[<p>工厂模式是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。这样做的好处是核心工厂类不在负责产品的创建，只负责具体工厂子类需要实现的接口。增加新的产品时不会对原有的工厂进行修改。<br>同简单工厂模式一样，我们用JDBC举例子。<br>我们正常使用JDBC如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Connection connection = ...</span><br><span class="line">Statement statement = connection.createStatement();</span><br><span class="line">ResultSet resultSet = statement.executeQuery(<span class="string">"SELECT * FROM MYTABLE"</span>);</span><br><span class="line"><span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">    <span class="comment">//数据处理</span></span><br><span class="line">&#125;</span><br><span class="line">statement.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure><a id="more"></a> <p>我们需要做的是先定义一个核心工厂接口，然后创建几个工厂的子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心工厂类接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConnectionFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">create</span><span class="params">(String url,String userName,String password)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySqlConnectionFactory</span> <span class="keyword">implements</span> <span class="title">ConnectionFactory</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        ConnectionFactoryManager.register(<span class="keyword">new</span> MySqlConnectionFactory());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">create</span><span class="params">(String url,String userName,String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acceptURL(url)) &#123;</span><br><span class="line">            <span class="comment">//创建并返回Connection</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">acceptURL</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> url.startsWith(<span class="string">"jdbc:mysql"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DB2ConnectionFactory</span> <span class="keyword">implements</span> <span class="title">ConnectionFactory</span></span>&#123;</span><br><span class="line">    <span class="comment">//省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OracleConnectionFactory</span> <span class="keyword">implements</span> <span class="title">ConnectionFactory</span></span>&#123;</span><br><span class="line">    <span class="comment">//省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建一个类去管理工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionFactoryManager</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;ConnectionFactory&gt; factories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String url,String userName,String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ConnectionFactory connectionFactory : factories) &#123;</span><br><span class="line">            Connection connection = connectionFactory.create(url, userName,password);</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> connection;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"can't create connection!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(ConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        factories.add(factory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在客户端直接通过ConnectionFactoryManager就可以生成Connection：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"cc.liuyong.mysql.MysqlConnectionFactory"</span>);</span><br><span class="line">Connection connection = ConnectionFactoryManager.getConnection(<span class="string">"jdbc:mysql://127.0.0.1:3306/mydatabase"</span>, <span class="string">"root"</span>, <span class="string">"123456"</span>);</span><br></pre></td></tr></table></figure><p>下面总结一下工厂模式的特点。<br><strong>UML图：</strong><br><img src="https://ws1.sinaimg.cn/large/80854ce7ly1fpqoyo90myj20vj09rq30.jpg" alt="工厂模式UML类图"><br><strong>优点：</strong></p><ol><li>客户端不需要依赖具体工厂和具体产品编程，只需要依赖于抽象工厂和抽象产品完成工作。（符合依赖倒置原则）</li><li>新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可。（符合开闭原则）</li></ol><p><strong>缺点：</strong></p><ol><li>添加新产品时，还需要添加对应的工厂类，增加了系统复杂性。</li><li>一个工厂只能创建一种产品。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工厂模式是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。这样做的好处是核心工厂类不在负责产品的创建，只负责具体工厂子类需要实现的接口。增加新的产品时不会对原有的工厂进行修改。&lt;br&gt;同简单工厂模式一样，我们用JDBC举例子。&lt;br&gt;我们正常使用JDBC如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Connection connection = ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Statement statement = connection.createStatement();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ResultSet resultSet = statement.executeQuery(&lt;span class=&quot;string&quot;&gt;&quot;SELECT * FROM MYTABLE&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (resultSet.next()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//数据处理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;statement.close();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;connection.close();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://liuyong.cc/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://liuyong.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>简单工厂模式</title>
    <link href="https://liuyong.cc/post/6b3bea20.html"/>
    <id>https://liuyong.cc/post/6b3bea20.html</id>
    <published>2018-03-26T21:23:18.000Z</published>
    <updated>2021-03-28T13:03:05.732Z</updated>
    
    <content type="html"><![CDATA[<p>简单工厂模式又称为静态工厂方法模式，定义一个专门的类来创建其它类的实例，根据传入参数的不同，创建的类的实例不同，但它们都有一个共同的父类。</p><p>我们正常使用JDBC如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Connection connection = ...</span><br><span class="line">Statement statement = connection.createStatement();</span><br><span class="line">ResultSet resultSet = statement.executeQuery(<span class="string">"SELECT * FROM MYTABLE"</span>);</span><br><span class="line"><span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">    <span class="comment">//数据处理</span></span><br><span class="line">&#125;</span><br><span class="line">statement.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure><a id="more"></a> <p>如果使用简单工厂模式进行连接不同的数据库，就是如下形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">create</span><span class="params">(String type, Properties info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"mysql"</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MySqlConnection(info);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"oracle"</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> OracleConnection(info);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"db2"</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DB2Connection(info);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeErrorException(<span class="keyword">null</span>, <span class="string">"unsupported db type ="</span> + type);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面写法比较笨重，打成jar包后无法修改，不符合开闭原则，可以通过反射和配置文件增加灵活性。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionFactory2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">create</span><span class="params">(String type, Properties info)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clz = getConnectionClass(type);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor&lt;?&gt; constructor = clz.getConstructor(Properties<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">return</span> (Connection) constructor.newInstance(info);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"unsupported db type ="</span> + type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Class <span class="title">getConnectionClass</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现略</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来总结一下简单工厂模式的特点。<br><strong>结构：</strong><br><img src="https://ws1.sinaimg.cn/large/80854ce7ly1fpqiqdxt9ij20rn09t0st.jpg" alt="简单工厂模式UML图"><br><strong>优点：</strong></p><ol><li>通过工厂，客户端免于创建对象的责任，只需要负责消费对象即可。</li><li>利用对象多态性和里氏代换原则，在运行时子类覆盖父类对象，易于扩展。</li></ol><p><strong>缺点：</strong></p><ol><li>对扩展开放，对修改也开放，不符合开闭原则（通过反射可消除此问题）。</li><li>当产品种类庞大之后，难以进行维护。</li></ol><p><strong>在JDK中的应用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DateFormat中的应用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DateFormat</span> <span class="keyword">extends</span> <span class="title">Format</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其它省略</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> DateFormat <span class="title">get</span><span class="params">(LocaleProviderAdapter adapter, <span class="keyword">int</span> timeStyle, <span class="keyword">int</span> dateStyle, Locale loc)</span> </span>&#123;</span><br><span class="line">        DateFormatProvider provider = adapter.getDateFormatProvider();</span><br><span class="line">        DateFormat dateFormat;</span><br><span class="line">        <span class="keyword">if</span> (timeStyle == -<span class="number">1</span>) &#123;</span><br><span class="line">            dateFormat = provider.getDateInstance(dateStyle, loc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (dateStyle == -<span class="number">1</span>) &#123;</span><br><span class="line">                dateFormat = provider.getTimeInstance(timeStyle, loc);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dateFormat = provider.getDateTimeInstance(dateStyle, timeStyle, loc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dateFormat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单工厂模式又称为静态工厂方法模式，定义一个专门的类来创建其它类的实例，根据传入参数的不同，创建的类的实例不同，但它们都有一个共同的父类。&lt;/p&gt;
&lt;p&gt;我们正常使用JDBC如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Connection connection = ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Statement statement = connection.createStatement();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ResultSet resultSet = statement.executeQuery(&lt;span class=&quot;string&quot;&gt;&quot;SELECT * FROM MYTABLE&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (resultSet.next()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//数据处理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;statement.close();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;connection.close();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://liuyong.cc/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://liuyong.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机内存区域划分</title>
    <link href="https://liuyong.cc/post/1727f503.html"/>
    <id>https://liuyong.cc/post/1727f503.html</id>
    <published>2018-03-25T15:23:20.000Z</published>
    <updated>2021-03-28T13:03:05.732Z</updated>
    
    <content type="html"><![CDATA[<p>java虚拟机的主要作用是加载并执行class文件。而在执行class文件中，如何存放class中的代码？运行过程中会生成大量的对象，这些对象如何存储？同时在执行过程中如何保存执行状态？其实都保存在Java内存区域中，而如何合理的划分这个区域，是我们关注的重点。<br>根据《Java虚拟机规范》的规定，Java虚拟机所管理的内存将分成如下几个运行时数据区域。</p><a id="more"></a> ![Java虚拟机运行时数据区][1]<h3 id="一、程序计数器"><a href="#一、程序计数器" class="headerlink" title="一、程序计数器"></a>一、程序计数器</h3><p>程序计数器用来存储下一条指令的地址，字节码解释器就是通过改变程序计数器的值来选取下一条指令的。<br><strong>特性：</strong></p><ol><li>和线程相关联，每个线程都有一个私有程序寄存器。（为的是多条线程切换时计数器不受影响）</li><li>执行Native方法时，计数器值为Undefined。（所有这个区域没有规定任何OutOfMemoryError情况）</li></ol><h3 id="二、虚拟机栈"><a href="#二、虚拟机栈" class="headerlink" title="二、虚拟机栈"></a>二、虚拟机栈</h3><p>虚拟机栈是线程的执行区域，保存着线程中方法调用的状态。每个方法都对应一个栈帧，一个方法从调用到结束，就是一个栈帧从压栈到出栈的过程。（栈帧保存着此方法的局部变量表、操作数栈、动态链接、方法出口等信息）<br><strong>特性：</strong></p><ol><li>线程私有，每个线程都有自己的栈，生命周期与线程相同。</li><li>栈帧中局部变量表的大小在方法运行期间固定。（编译期间就可知8种基本类型、对象引用(reference类型)和returnAddress类型，long和double占2个局部变量空间(Slot)，其余类型占1个）</li><li>线程请求的栈深度大于虚拟机允许深度，抛出StackOverflowError。</li><li>如果栈可以动态扩展，但是无法申请到足够的空间时，抛出OutOfMemoryError。</li></ol><h3 id="三、本地方法栈"><a href="#三、本地方法栈" class="headerlink" title="三、本地方法栈"></a>三、本地方法栈</h3><p>同虚拟机栈作用相似，它调用的是由C/C++编写的本地方法。<br><strong>特性：</strong></p><ol><li>HotSpot将本地方法栈和虚拟机栈合二为一。</li><li>同样具有StackOverflowError和OutOfMemoryError。</li></ol><h3 id="四、堆"><a href="#四、堆" class="headerlink" title="四、堆"></a>四、堆</h3><p>所有运行时产生的对象全部都存放于堆中，是GC关注的重点区域。<br><strong>特性：</strong></p><ol><li>被所有线程共享，在虚拟机启动时被创建。</li><li>是GC管理的主要区域。</li><li>物理上可以不连续，逻辑是连续即可。</li><li>会发生内存泄漏或者内存溢出。(内存泄漏是指对象无用时无法被被GC回收，内存溢出是指无法申请到足够内存)</li></ol><h3 id="五、方法区"><a href="#五、方法区" class="headerlink" title="五、方法区"></a>五、方法区</h3><p>用于存储已被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码等数据。<br><strong>特性：</strong></p><ol><li>一个虚拟机中只有一个方法区，可以被各个线程共享。</li><li>生命周期很长，一般伴随整个程序的生命周期。</li><li>可以选择不实现垃圾收集，对这个区域的回收目标主要是：常量池的回收和类型的卸载。</li><li>方法区无法满足分配需求时，抛出OutOfMemoryError。</li></ol><h3 id="六、运行时常量池"><a href="#六、运行时常量池" class="headerlink" title="六、运行时常量池"></a>六、运行时常量池</h3><p>运行时常量池是方法区的一部分，用于存放生成的各种字面量和符号引用。<br><strong>特性：</strong></p><ol><li>必须是类被加载后，才能把此类的各个字面量和符号引用存到运行时常量池中。</li><li>具有动态性，可以将运行期间产生的新常量放入池中。(String.intern()作用：将首次出现的实例引用记录在常量池中)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java虚拟机的主要作用是加载并执行class文件。而在执行class文件中，如何存放class中的代码？运行过程中会生成大量的对象，这些对象如何存储？同时在执行过程中如何保存执行状态？其实都保存在Java内存区域中，而如何合理的划分这个区域，是我们关注的重点。&lt;br&gt;根据《Java虚拟机规范》的规定，Java虚拟机所管理的内存将分成如下几个运行时数据区域。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java虚拟机" scheme="https://liuyong.cc/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="Java虚拟机" scheme="https://liuyong.cc/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Java中的装箱和拆箱</title>
    <link href="https://liuyong.cc/post/7c65aac7.html"/>
    <id>https://liuyong.cc/post/7c65aac7.html</id>
    <published>2018-03-15T07:08:51.000Z</published>
    <updated>2021-03-28T13:03:05.732Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、什么是装箱？什么是拆箱？"><a href="#一、什么是装箱？什么是拆箱？" class="headerlink" title="一、什么是装箱？什么是拆箱？"></a>一、什么是装箱？什么是拆箱？</h3><p>Java为每种基本数据类型都提供了对应的包装器类型 ，基本类型到包装器类型之间的转换就是装箱和拆箱。</p><ul><li>装箱：自动将基本数据类型转换为包装器类型</li><li>拆箱：自动将包装器类型转换为基本数据类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="keyword">int</span> n = i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>基本数据类型</th><th>包装器类型</th></tr></thead><tbody><tr><td>int（4字节）</td><td>Integer</td></tr><tr><td>byte（1字节）</td><td>Byte</td></tr><tr><td>short（2字节）</td><td>Short</td></tr><tr><td>long（8字节）</td><td>Long</td></tr><tr><td>float（4字节）</td><td>Float</td></tr><tr><td>double（8字节）</td><td>Double</td></tr><tr><td>char（2字节）</td><td>Character</td></tr><tr><td>boolean（未定）</td><td>Boolean</td></tr></tbody></table><a id="more"></a><h3 id="二、装箱和拆箱的实现"><a href="#二、装箱和拆箱的实现" class="headerlink" title="二、装箱和拆箱的实现"></a>二、装箱和拆箱的实现</h3><p>装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。（xxx代表对应的基本数据类型）。 </p><p>如下面试题：</p><p>下面这段代码的输出结果是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        Integer i1 = <span class="number">100</span>;</span><br><span class="line">        Integer i2 = <span class="number">100</span>;</span><br><span class="line">        Integer i3 = <span class="number">200</span>;</span><br><span class="line">        Integer i4 = <span class="number">200</span>;</span><br><span class="line">         </span><br><span class="line">        System.out.println(i1==i2);</span><br><span class="line">        System.out.println(i3==i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure><p>输出结果表明i1和i2指向的是同一个对象，而i3和i4指向的是不同的对象。此时只需一看源码便知究竟，下面这段代码是Integer的valueOf方法的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= -<span class="number">128</span> &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + <span class="number">128</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>而其中IntegerCache类的实现为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">static</span> &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// high value may be configured by property</span></span><br><span class="line">           <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">           <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// Use Long.decode here to avoid invoking methods that</span></span><br><span class="line">               <span class="comment">// require Integer's autoboxing cache to be initialized</span></span><br><span class="line">               <span class="keyword">int</span> i = Long.decode(integerCacheHighPropValue).intValue();</span><br><span class="line">               i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">               <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">               h = Math.min(i, Integer.MAX_VALUE - -low);</span><br><span class="line">           &#125;</span><br><span class="line">           high = h;</span><br><span class="line"></span><br><span class="line">           cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">           <span class="keyword">int</span> j = low;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">               cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>从这两段代码可以看出，在通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。</p><p>上面的代码中i1和i2的数值为100，因此会直接从cache中取已经存在的对象，所以i1和i2指向的是同一个对象，而i3和i4则是分别指向不同的对象。</p><p><strong>Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的。</strong> </p><ul><li>Short类源码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Short <span class="title">valueOf</span><span class="params">(<span class="keyword">short</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">int</span> sAsInt = s;</span><br><span class="line">    <span class="keyword">if</span> (sAsInt &gt;= -<span class="number">128</span> &amp;&amp; sAsInt &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">        <span class="keyword">return</span> ShortCache.cache[sAsInt + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Short(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortCache</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ShortCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Short cache[] = <span class="keyword">new</span> Short[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> Short((<span class="keyword">short</span>)(i - <span class="number">128</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Byte类源码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Byte <span class="title">valueOf</span><span class="params">(<span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">      <span class="keyword">return</span> ByteCache.cache[(<span class="keyword">int</span>)b + offset];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteCache</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">ByteCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> Byte cache[] = <span class="keyword">new</span> Byte[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">static</span> &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">              cache[i] = <span class="keyword">new</span> Byte((<span class="keyword">byte</span>)(i - <span class="number">128</span>));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>Character类源码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Character <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">        <span class="keyword">return</span> CharacterCache.cache[(<span class="keyword">int</span>)c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Character(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CharacterCache</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CharacterCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Character cache[] = <span class="keyword">new</span> Character[<span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> Character((<span class="keyword">char</span>)i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Long类源码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= -<span class="number">128</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123; <span class="comment">// will cache</span></span><br><span class="line">        <span class="keyword">return</span> LongCache.cache[(<span class="keyword">int</span>)l + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Long(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LongCache</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LongCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Long cache[] = <span class="keyword">new</span> Long[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> Long(i - <span class="number">128</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Double、Float的valueOf方法的实现是类似的。</strong> </p><ul><li>Double类源码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Double(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Float类源码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Float <span class="title">valueOf</span><span class="params">(<span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Float(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、题目测试"><a href="#三、题目测试" class="headerlink" title="三、题目测试"></a>三、题目测试</h3><p>下面程序的输出结果是什么？ </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        Integer a = <span class="number">1</span>;</span><br><span class="line">        Integer b = <span class="number">2</span>;</span><br><span class="line">        Integer c = <span class="number">3</span>;</span><br><span class="line">        Integer d = <span class="number">3</span>;</span><br><span class="line">        Integer e = <span class="number">321</span>;</span><br><span class="line">        Integer f = <span class="number">321</span>;</span><br><span class="line">        Long g = <span class="number">3L</span>;</span><br><span class="line">        Long h = <span class="number">2L</span>;</span><br><span class="line">         </span><br><span class="line">        System.out.println(c==d);</span><br><span class="line">        System.out.println(e==f);</span><br><span class="line">        System.out.println(c==(a+b));</span><br><span class="line">        System.out.println(c.equals(a+b));</span><br><span class="line">        System.out.println(g==(a+b));</span><br><span class="line">        System.out.println(g.equals(a+b));</span><br><span class="line">        System.out.println(g.equals(a+h));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span><span class="comment">//读取缓存内同一个对象</span></span><br><span class="line"><span class="keyword">false</span><span class="comment">//在-128~127之外，新建对象</span></span><br><span class="line"><span class="keyword">true</span><span class="comment">//a+b触发自动拆箱过程，比较它们值相等</span></span><br><span class="line"><span class="keyword">true</span><span class="comment">//a+b先触发自动拆箱，再触发自动装箱</span></span><br><span class="line"><span class="keyword">true</span><span class="comment">//a+b触发自动拆箱过程，比较它们值相等</span></span><br><span class="line"><span class="keyword">false</span><span class="comment">//a+b先拆箱，然后通过Integer.valueOf装箱，所以类型不同</span></span><br><span class="line"><span class="keyword">true</span><span class="comment">//a+h先拆箱，然后通过Long.valueOf装箱，为缓存内同一对象</span></span><br></pre></td></tr></table></figure><p>注意事项：<strong>当 “==”运算符的两个操作数都是 包装器类型的引用，则是比较指向的是否是同一个对象，而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。另外，对于包装器类型，equals方法并不会进行类型转换。</strong> </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、什么是装箱？什么是拆箱？&quot;&gt;&lt;a href=&quot;#一、什么是装箱？什么是拆箱？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是装箱？什么是拆箱？&quot;&gt;&lt;/a&gt;一、什么是装箱？什么是拆箱？&lt;/h3&gt;&lt;p&gt;Java为每种基本数据类型都提供了对应的包装器类型 ，基本类型到包装器类型之间的转换就是装箱和拆箱。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;装箱：自动将基本数据类型转换为包装器类型&lt;/li&gt;
&lt;li&gt;拆箱：自动将包装器类型转换为基本数据类型&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Integer i = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;//装箱&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n = i;   &lt;span class=&quot;comment&quot;&gt;//拆箱&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;基本数据类型&lt;/th&gt;
&lt;th&gt;包装器类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;int（4字节）&lt;/td&gt;
&lt;td&gt;Integer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;byte（1字节）&lt;/td&gt;
&lt;td&gt;Byte&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;short（2字节）&lt;/td&gt;
&lt;td&gt;Short&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long（8字节）&lt;/td&gt;
&lt;td&gt;Long&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float（4字节）&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;double（8字节）&lt;/td&gt;
&lt;td&gt;Double&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char（2字节）&lt;/td&gt;
&lt;td&gt;Character&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;boolean（未定）&lt;/td&gt;
&lt;td&gt;Boolean&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="https://liuyong.cc/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java对象的初始化顺序</title>
    <link href="https://liuyong.cc/post/85230167.html"/>
    <id>https://liuyong.cc/post/85230167.html</id>
    <published>2018-03-10T22:56:44.000Z</published>
    <updated>2021-03-28T13:03:05.732Z</updated>
    
    <content type="html"><![CDATA[<p>加载类</p><ol><li>为父类静态属性分配内存并赋值 / 执行父类静态代码段 （按代码顺序）</li><li>为子类静态属性分配内存并赋值 / 执行子类静态代码段 （按代码顺序）</li></ol><a id="more"></a> <p>创建对象</p><ol><li>为父类实例属性分配内存并赋值 / 执行父类非静态代码段 （按代码顺序）</li><li>执行父类构造器</li><li>为子类实例属性分配内存并赋值 / 执行子类非静态代码段 （按代码顺序）</li><li>执行子类构造器</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;加载类&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为父类静态属性分配内存并赋值 / 执行父类静态代码段 （按代码顺序）&lt;/li&gt;
&lt;li&gt;为子类静态属性分配内存并赋值 / 执行子类静态代码段 （按代码顺序）&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="https://liuyong.cc/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java运行时异常与一般异常有何异同</title>
    <link href="https://liuyong.cc/post/873428a7.html"/>
    <id>https://liuyong.cc/post/873428a7.html</id>
    <published>2018-03-09T07:08:51.000Z</published>
    <updated>2021-03-28T13:03:05.732Z</updated>
    
    <content type="html"><![CDATA[<p>Throwable是所有Java程序中错误处理的父类，有两种资类：Error和Exception。</p><ul><li>Error：表示由JVM所侦测到的无法预期的错误，由于这是属于JVM层次的严重错误，导致JVM无法继续执行，因此，这是不可捕捉到的，无法采取任何恢复的操作，顶多只能显示错误信息。</li><li>Exception：表示可恢复的例外，这是可捕捉到的。 </li></ul><p>Java提供了两类主要的异常:runtime exception和checked exception </p><ul><li>checked 异常也就是我们经常遇到的IO异常，以及SQL异常都是这种异常。对于这种异常，JAVA编译器强制要求我们必需对出现的这些异常进行catch。这类异常一般是外部错误,例如试图从文件尾后读取数据等,这并不是程序本身的错误,而是在应用环境中出现的外部错误 。</li><li>runtime exception，也称运行时异常，我们可以不处理。当出现这样的异常时，总是由虚拟机接管。出现运行时异常后，系统会把异常一直往上层抛，一直遇到处理代码。如果没有处理块，到最上层，如果是多线程就由Thread.run()抛出，如果是单线程就被main()抛出。抛出之后，如果是线程，这个线程也就退出了。如果是主程序抛出的异常，那么这整个程序也就退出了 。</li></ul><a id="more"></a> <p>常见的运行时异常：</p><ul><li>ArrayStoreException：试图将错误类型的对象存储到一个对象数组时抛出的异常</li><li>ClassCastException：试图将对象强制转换为不是实例的子类时，抛出该异常 </li><li>IllegalArgumentException：抛出的异常表明向方法传递了一个不合法或不正确的参数</li><li>IndexOutOfBoundsException ：指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出 </li><li>NoSuchElementException：表明枚举中没有更多的元素 </li><li>NullPointerException：当应用程序试图在需要对象的地方使用 null 时，抛出该异常 </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Throwable是所有Java程序中错误处理的父类，有两种资类：Error和Exception。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Error：表示由JVM所侦测到的无法预期的错误，由于这是属于JVM层次的严重错误，导致JVM无法继续执行，因此，这是不可捕捉到的，无法采取任何恢复的操作，顶多只能显示错误信息。&lt;/li&gt;
&lt;li&gt;Exception：表示可恢复的例外，这是可捕捉到的。 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Java提供了两类主要的异常:runtime exception和checked exception &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;checked 异常也就是我们经常遇到的IO异常，以及SQL异常都是这种异常。对于这种异常，JAVA编译器强制要求我们必需对出现的这些异常进行catch。这类异常一般是外部错误,例如试图从文件尾后读取数据等,这并不是程序本身的错误,而是在应用环境中出现的外部错误 。&lt;/li&gt;
&lt;li&gt;runtime exception，也称运行时异常，我们可以不处理。当出现这样的异常时，总是由虚拟机接管。出现运行时异常后，系统会把异常一直往上层抛，一直遇到处理代码。如果没有处理块，到最上层，如果是多线程就由Thread.run()抛出，如果是单线程就被main()抛出。抛出之后，如果是线程，这个线程也就退出了。如果是主程序抛出的异常，那么这整个程序也就退出了 。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="https://liuyong.cc/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>String、StringBuffer、StringBuilder的区别</title>
    <link href="https://liuyong.cc/post/cccfa5c8.html"/>
    <id>https://liuyong.cc/post/cccfa5c8.html</id>
    <published>2018-03-07T07:08:51.000Z</published>
    <updated>2021-03-28T13:03:05.732Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、-字符串的不变性"><a href="#一、-字符串的不变性" class="headerlink" title="一、 字符串的不变性"></a>一、 字符串的不变性</h3><p>String 字符串的不变性：<strong>String 对象创建后则不能被修改，是不可变的</strong>。  </p><p>下面看看 String 不变性的原因</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The value is used for character storage. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The offset is the first index of the storage that is used. *</span></span><br><span class="line"><span class="comment">private final int offset;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/** The count is the number of characters in the String. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure><p>用于存放字符的数组被声明为final的，因此只能赋值一次，不可再更改。</p><p>重新赋值修改字符串<strong>其实是创建了新的对象，所指向的内存空间不同</strong>。  </p><h3 id="二、-StringBuffer和StringBuilder介绍"><a href="#二、-StringBuffer和StringBuilder介绍" class="headerlink" title="二、 StringBuffer和StringBuilder介绍"></a>二、 StringBuffer和StringBuilder介绍</h3><p>StringBuilder：字符串变量（非线程安全）。在内部，StringBuilder对象被当作是一个包含字符序列的变长数组。</p><p>StringBuffer：字符串变量（Synchronized，即线程安全）。StringBuffer的线程安全，仅仅是保证jvm不抛出异常顺利的往下执行而已，它不保证逻辑正确和调用顺序正确。大多数时候，我们需要的不仅仅是线程安全，而是锁。</p><a id="more"></a> <h3 id="三、String，StringBuffer和StringBuilder区别"><a href="#三、String，StringBuffer和StringBuilder区别" class="headerlink" title="三、String，StringBuffer和StringBuilder区别"></a>三、String，StringBuffer和StringBuilder区别</h3><h4 id="1、可变性"><a href="#1、可变性" class="headerlink" title="1、可变性"></a>1、可变性</h4><ul><li>String类中用于存放字符的数组被声明为final的，因此只能赋值一次，不可再更改。</li><li>StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中用于存放字符的数组没有被声明为final的。所以可以知道StringBuilder与StringBuffer对象是可变的。</li></ul><h4 id="2、线程安全性"><a href="#2、线程安全性" class="headerlink" title="2、线程安全性"></a>2、线程安全性</h4><ul><li>String中的对象是不可变的，也就可以理解为常量，显然线程安全。</li><li>StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。看下源码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。看下源码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、性能"><a href="#3、性能" class="headerlink" title="3、性能"></a>3、性能</h4><ul><li><p>普通情况下：StringBuilder &gt;  StringBuffer  &gt;  String </p></li><li><p>由于StringBuilder 没有同步锁，所以速度上：StringBuilder &gt;StringBuffer</p></li><li><p>jdk1.5后，如果没有循环的情况下，把所有用加号连接的string运算都隐式的改写成StringBuilder ，单行用加号拼接字符串是没有性能损失的</p></li><li><p>但在有循环的情况下，编译器无法智能的替换成StringBuilder ，仍然会有不必要的性能损耗 </p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、-字符串的不变性&quot;&gt;&lt;a href=&quot;#一、-字符串的不变性&quot; class=&quot;headerlink&quot; title=&quot;一、 字符串的不变性&quot;&gt;&lt;/a&gt;一、 字符串的不变性&lt;/h3&gt;&lt;p&gt;String 字符串的不变性：&lt;strong&gt;String 对象创建后则不能被修改，是不可变的&lt;/strong&gt;。  &lt;/p&gt;
&lt;p&gt;下面看看 String 不变性的原因&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/** The value is used for character storage. */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; value[];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/** The offset is the first index of the storage that is used. *&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;private final int offset;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/** The count is the number of characters in the String. */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; count;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;用于存放字符的数组被声明为final的，因此只能赋值一次，不可再更改。&lt;/p&gt;
&lt;p&gt;重新赋值修改字符串&lt;strong&gt;其实是创建了新的对象，所指向的内存空间不同&lt;/strong&gt;。  &lt;/p&gt;
&lt;h3 id=&quot;二、-StringBuffer和StringBuilder介绍&quot;&gt;&lt;a href=&quot;#二、-StringBuffer和StringBuilder介绍&quot; class=&quot;headerlink&quot; title=&quot;二、 StringBuffer和StringBuilder介绍&quot;&gt;&lt;/a&gt;二、 StringBuffer和StringBuilder介绍&lt;/h3&gt;&lt;p&gt;StringBuilder：字符串变量（非线程安全）。在内部，StringBuilder对象被当作是一个包含字符序列的变长数组。&lt;/p&gt;
&lt;p&gt;StringBuffer：字符串变量（Synchronized，即线程安全）。StringBuffer的线程安全，仅仅是保证jvm不抛出异常顺利的往下执行而已，它不保证逻辑正确和调用顺序正确。大多数时候，我们需要的不仅仅是线程安全，而是锁。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="https://liuyong.cc/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java中的继承、封装、多态</title>
    <link href="https://liuyong.cc/post/e7802133.html"/>
    <id>https://liuyong.cc/post/e7802133.html</id>
    <published>2018-03-03T07:08:51.000Z</published>
    <updated>2021-03-28T13:03:05.732Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、继承"><a href="#一、继承" class="headerlink" title="一、继承"></a>一、继承</h3><ul><li>Java只支持单继承，不支持多重继承</li><li>Java 中用关键字extends 来实现单继承</li><li>构造方法不能被继承 </li><li>不能继承私有属性与方法</li></ul><h3 id="二、封装"><a href="#二、封装" class="headerlink" title="二、封装"></a>二、封装</h3><p>封装是Java面向对象的特点的表现，即把对象的全部属性和全部服务结合在一起，形成一个不可分割的独立单位，同时尽可能隐藏对象的内部结构。</p><p>在Java中是通过各种访问限定符来实现数据封装的，共分为四种访问级别(由高到低)：</p><ul><li>public(公共) ：可以在任何地方(指的是任何包中)的任何类中被访问</li><li>protected(受保护的) ：可以在同包中的任何类、不同包中的任何当前类的子类中所访问</li><li>friendly(缺省的) ：只能在同包的类中访问</li><li>private(私有的) ：只能在当前类中被访问</li></ul><p><strong>类只可以定义为默认或公共级别(嵌套类除外)。</strong> </p><a id="more"></a> <h3 id="三、多态"><a href="#三、多态" class="headerlink" title="三、多态"></a>三、多态</h3><p>Java多态性的概念也可以被说成“一个接口，多个方法”。Java实现运行时多态性的基础是动态方法调度，<strong>它是一种在运行时而不是在编译期调用重载方法的机制</strong>。 </p><p>方法的重写Overriding和重载Overloading是Java多态性的不同表现</p><ul><li>重写Overriding是<strong>父类与子类之间多态性</strong>的一种表现， 如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。 </li><li>重载Overloading是<strong>一个类中多态性</strong>的一种表现，如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。 </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、继承&quot;&gt;&lt;a href=&quot;#一、继承&quot; class=&quot;headerlink&quot; title=&quot;一、继承&quot;&gt;&lt;/a&gt;一、继承&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Java只支持单继承，不支持多重继承&lt;/li&gt;
&lt;li&gt;Java 中用关键字extends 来实现单继承&lt;/li&gt;
&lt;li&gt;构造方法不能被继承 &lt;/li&gt;
&lt;li&gt;不能继承私有属性与方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;二、封装&quot;&gt;&lt;a href=&quot;#二、封装&quot; class=&quot;headerlink&quot; title=&quot;二、封装&quot;&gt;&lt;/a&gt;二、封装&lt;/h3&gt;&lt;p&gt;封装是Java面向对象的特点的表现，即把对象的全部属性和全部服务结合在一起，形成一个不可分割的独立单位，同时尽可能隐藏对象的内部结构。&lt;/p&gt;
&lt;p&gt;在Java中是通过各种访问限定符来实现数据封装的，共分为四种访问级别(由高到低)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;public(公共) ：可以在任何地方(指的是任何包中)的任何类中被访问&lt;/li&gt;
&lt;li&gt;protected(受保护的) ：可以在同包中的任何类、不同包中的任何当前类的子类中所访问&lt;/li&gt;
&lt;li&gt;friendly(缺省的) ：只能在同包的类中访问&lt;/li&gt;
&lt;li&gt;private(私有的) ：只能在当前类中被访问&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;类只可以定义为默认或公共级别(嵌套类除外)。&lt;/strong&gt; &lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="https://liuyong.cc/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="https://liuyong.cc/post/72e3b671.html"/>
    <id>https://liuyong.cc/post/72e3b671.html</id>
    <published>2018-01-04T22:54:03.000Z</published>
    <updated>2021-03-28T13:03:05.732Z</updated>
    
    <content type="html"><![CDATA[<p>策略模式在《Head First 设计模式》中的定义如下：</p><p><strong>策略模式定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。</strong></p><p>我们日常开发中会在什么时候用到此模式呢？</p><ol><li>几个类的主要逻辑相同，只在部分逻辑的算法和行为上稍有区别的情况</li><li>有几种相似的行为或算法，需要动态地决定使用哪一种</li></ol><p>具体如何使用策略模式，让我们举个《Head First 设计模式》中的例子:</p><a id="more"></a> <p><em>假设有一个模拟鸭子的游戏，游戏中会出现各种鸭子，一边游泳戏水，一边呱呱叫。这个游戏的内部设计了一个鸭子超类Duck，并让各种鸭子继承此超类。</em></p><p><em>现在有个新的功能：让部分鸭子能飞</em></p><p>我们先来实现超类Duck，然后进行问题分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 所有的鸭子都会呱呱叫，由Duck类负责实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 所有的鸭子都会游泳，由Duck类负责实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;  <span class="comment">// 每个鸭子的子类负责实现自己的display</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体分析如下：</p><ol><li>我们是否可以直接在Duck里面添加fly()方法，答案是否，这样的话所有继承Duck的子类都会有fly()方法，橡皮鸭继承自Duck，但是它不会飞，却具有fly()方法。</li><li>我们是否可以定义一个Flyable接口，让Duck的子类来实现。同样是否，比如小白鸭和小黄鸭分别是Duck的子类，它们具有相同的飞行行为，但却各自实现一遍Flyable接口，代码复用性太低。</li><li>我们是不是可以写个FlyBehavior接口，然后实现其子类：<ol><li>FlyWithWings继承自FlyBehavior，实现鸭子正常飞行；</li><li>FlyNoWay继承自FlyBehavior，实现不会飞的鸭子的行为；</li><li>FlyRocketPowered继承自FlyBehavior，实现鸭子火箭般飞行；</li></ol></li></ol><p>让我们来看具体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line"><span class="comment">//---------------------</span></span><br><span class="line">    FlyBehavior flyBehavior;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performFly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        flyBehavior.fly();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlyBehavior</span><span class="params">(FlyBehavior flyBehavior)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flyBehavior = flyBehavior;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//---------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"All ducks float, even decoys!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MallardDuck</span> <span class="keyword">extends</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MallardDuck</span><span class="params">()</span></span>&#123;</span><br><span class="line">        flyBehavior = <span class="keyword">new</span> FlyWithWings();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I'm a real Mallard duck"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FlyBehavior</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyWithWings</span> <span class="keyword">implements</span> <span class="title">FlyBehavior</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I'm flying!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyNoWay</span> <span class="keyword">implements</span> <span class="title">FlyBehavior</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I can't fly"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyRocketPowered</span> <span class="keyword">implements</span> <span class="title">FlyBehavior</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I'm flying with a rocket!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DuckTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Duck mallard = <span class="keyword">new</span> MallardDuck();</span><br><span class="line">        mallard.performFly();</span><br><span class="line">        mallard.setFlyBehavior(<span class="keyword">new</span> FlyRocketPowered());</span><br><span class="line">        mallard.performFly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码可以看出策略模式的结构：</p><ul><li>环境类：负责对策略进行二次封装。（Duck类）</li><li>抽象策略类：当各个实现类中存在着重复的逻辑时，则使用抽象类来封装这部分公共的代码。（FlyBehavior接口）</li><li>具体策略类：由一组封装了算法或行为的类来担任，这些类之间可以根据需要自由替换。（FlyWithWings类、FlyNoWay类、FlyRocketPowered类）</li></ul><p>策略模式的优点：</p><ul><li>策略类之间可以自由切换</li><li>易于扩展，方便添加修改策略类</li><li>避免使用多重条件，若没有策略模式，需要添加许多判断条件进行判断使用哪一种算法</li></ul><p>策略模式的缺点：</p><ul><li>必须知道所有的策略类，并自行决定使用哪一个策略类</li><li>可能会产生过多策略类，也不容易维护，这时候需要享元模式减少策略类数量。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;策略模式在《Head First 设计模式》中的定义如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;策略模式定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们日常开发中会在什么时候用到此模式呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;几个类的主要逻辑相同，只在部分逻辑的算法和行为上稍有区别的情况&lt;/li&gt;
&lt;li&gt;有几种相似的行为或算法，需要动态地决定使用哪一种&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体如何使用策略模式，让我们举个《Head First 设计模式》中的例子:&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://liuyong.cc/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://liuyong.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java源码分析之Object类</title>
    <link href="https://liuyong.cc/post/8946258a.html"/>
    <id>https://liuyong.cc/post/8946258a.html</id>
    <published>2017-12-31T22:31:01.000Z</published>
    <updated>2021-03-28T13:03:05.732Z</updated>
    
    <content type="html"><![CDATA[<p>最近在研究java常见类的源码，夯实一下基础。今天先总结一下Object类。</p><p>Object类是java中所有类的基类，位于java.lang包中。而java.lang包又是java中最基础最核心的包，无需手动导入，编译时自动导入。</p><h3 id="Native方法"><a href="#Native方法" class="headerlink" title="Native方法"></a>Native方法</h3><p>在讲Object之前，先来补充一下知识点，什么是Native方法。</p><p>“A native method is a Java method whose implementation is provided by non-java code.”</p><p>简单来说就是：<strong>一个native方法是由非java语言来实现的java方法</strong>。 </p><p>通常情况下在定义一个native方法时，不去提供实体类，因为实体类由非java语言在外面已经实现。所以这也意味着<strong>native不能与abstract方法连用</strong>。那为什么要用Native呢，当然是因为某些高效率任务用java不易实现，而像C/C++这样的语言相对来说容易些。</p><hr><p>Object类里面没有定义属性，里面只包含13种方法。</p><h3 id="registerNatives"><a href="#registerNatives" class="headerlink" title="registerNatives()"></a>registerNatives()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  registerNatives();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>registerNatives()被native修饰，意味着此方法并不是在Java中实现的。</p><p>简单来说registerNatives()的作用是将非java语言实现的方法与java中的native方法一一对应起来，就像英文名Zhang San和中文名张三匹配起来一样。</p><p>下面的static方法块的作用就是这个类在被类加载器加载时执行一次，且仅执行一次。</p><a id="more"></a> <h3 id="getClass"><a href="#getClass" class="headerlink" title="getClass()"></a>getClass()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure><p>getClass()也是一个native方法，其作用是返回当前对象的类。等一下，类不是对象的描述嘛，对象是类的实现啊，描述也能返回吗？哈哈，看见Class&lt;?&gt;了嘛，它是描述类的类，姑且称为<strong>元类</strong>吧，实际返回的是元类的对象。</p><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>也是native方法，返回的是int型的哈希码。那它的作用是什么呢？当然是为用到哈希表功能的地方行方便了。</p><p>有了哈希码，直接计算出地址来判断是否对象存在，就不用每次都遍历然后equals()了。</p><h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法用来判断<strong>两个对象的内容</strong>是否相等。常规的==判断的是内存地址是否相等。等一下，不是说判断对象不用==用equals的嘛，你不也是==实现的嘛，坑爹呢吧。哈哈，人家是可以被重写的嘛。看看String，重写成逐个char对比的。当然重写了你也<strong>别忘了重写hashCode()方法啊</strong>。为啥要重写hashCode()啊？来自成文的规定：</p><ul><li>在java应用程序执行期间，如果在equals方法比较中所用的信息没有被修改，那么在同一个对象上多次调用hashCode方法时必须一致地返回相同的整数。如果多次执行同一个应用时，不要求该整数必须相同。</li><li>如果两个对象通过调用equals方法是相等的，那么这两个对象调用hashCode方法必须返回相同的整数。</li><li>如果两个对象通过调用equals方法是不相等的，不要求这两个对象调用hashCode方法必须返回不同的整数。但是程序员应该意识到对不同的对象产生不同的hash值可以提供哈希表的性能。</li></ul><p>看到了吧，为啥两个中一个变了，另一个也要重写了吧。</p><h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure><p>又又又是native方法，克隆作用是在堆中新建一个和被克隆对象一摸一样的对象，然后返回这个新对象的地址。</p><p>但是有个坑要注意，对象中成员变量是基本类型好说，如果也是对象的话，成员变量的值其实可是个引用啊，被克隆回来也是个引用啊，所以那个被指向的对象内容变了，那么克隆的和被克隆对象都会被影响，这就是所谓的<strong>浅拷贝</strong>。</p><p>克隆就克隆，后面那throws CloneNotSupportedException是啥意思，为啥要用protected修饰。</p><p>这里我们要说一下protected，单protected就可以写一篇文章了。这里只说一下：<strong>当两个类不在同一个包中的时候，只能在子类内部通过子类的引用访问父类的protected属性或者方法</strong>。比如写了一个Object的子类ObjectSon，然后去另外一个包下面new ObjectSon()，这时候你是调不到ObjectSon里面的protected属性和方法的。</p><p>也就是说你想要在此对象外面用clone方法，必须将clone()改成public的。改成public后，它的子类或者子子孙孙类都具有clone功能了，这也不是我们想要的。所以设计者做了个开关：Cloneable接口，只有实现该接口，并且public clone()，才能在外面使用clone功能。不实现Cloneable接口报Object的CloneNotSupportedException错误。</p><p>要想正确使用克隆，只有通过clone()和Cloneable接口组合。</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看代码就知道返回的是对象的类型加上其哈希值，中间用@隔开。由上面equals()第三条规范可知，同一个哈希值并不一定代表同一个对象，所以toString()返回结果相同也未必会是同一个对象。</p><h3 id="notify"><a href="#notify" class="headerlink" title="notify()"></a>notify()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>在多线程中用到的方法，其作用是唤醒在此对象监视器上等待的单个线程。</p><h3 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll()"></a>notifyAll()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>同样也是多线程方法，但是它是唤醒监视器上所有等待的线程。</p><h3 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">      <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    timeout++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  wait(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>wait()的作用是将当前线程设为等待，直到被notify()/notifyAll()唤醒。</p><p>wait(long timeout)和上面相同，不过超过了参数里设定的时间后，也会自动唤醒，<strong>timeout的单位是毫秒</strong>。</p><p>wait(long timeout, int nanos)和wait(long timeout)的作用相同，<strong>timeout和nanos的单位是纳秒：1000000*timeout+nanos</strong>。</p><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>其作用是告诉jvm，垃圾该回收了，然后就是默默等待回收就行了。因为有垃圾回收机制，通常我们不去主动调用它，除非一种情况是此<strong>对象不是由java来生成的</strong>，垃圾回收机制监管不到，只能通过主动调用告诉它该回收了。</p><h3 id="Object"><a href="#Object" class="headerlink" title="Object()"></a>Object()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Object</span><span class="params">()</span></span>&#123;&#125;;</span><br></pre></td></tr></table></figure><p>默认的类构造器，不需要啥特殊解释。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在研究java常见类的源码，夯实一下基础。今天先总结一下Object类。&lt;/p&gt;
&lt;p&gt;Object类是java中所有类的基类，位于java.lang包中。而java.lang包又是java中最基础最核心的包，无需手动导入，编译时自动导入。&lt;/p&gt;
&lt;h3 id=&quot;Native方法&quot;&gt;&lt;a href=&quot;#Native方法&quot; class=&quot;headerlink&quot; title=&quot;Native方法&quot;&gt;&lt;/a&gt;Native方法&lt;/h3&gt;&lt;p&gt;在讲Object之前，先来补充一下知识点，什么是Native方法。&lt;/p&gt;
&lt;p&gt;“A native method is a Java method whose implementation is provided by non-java code.”&lt;/p&gt;
&lt;p&gt;简单来说就是：&lt;strong&gt;一个native方法是由非java语言来实现的java方法&lt;/strong&gt;。 &lt;/p&gt;
&lt;p&gt;通常情况下在定义一个native方法时，不去提供实体类，因为实体类由非java语言在外面已经实现。所以这也意味着&lt;strong&gt;native不能与abstract方法连用&lt;/strong&gt;。那为什么要用Native呢，当然是因为某些高效率任务用java不易实现，而像C/C++这样的语言相对来说容易些。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Object类里面没有定义属性，里面只包含13种方法。&lt;/p&gt;
&lt;h3 id=&quot;registerNatives&quot;&gt;&lt;a href=&quot;#registerNatives&quot; class=&quot;headerlink&quot; title=&quot;registerNatives()&quot;&gt;&lt;/a&gt;registerNatives()&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;native&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;registerNatives&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  registerNatives();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;registerNatives()被native修饰，意味着此方法并不是在Java中实现的。&lt;/p&gt;
&lt;p&gt;简单来说registerNatives()的作用是将非java语言实现的方法与java中的native方法一一对应起来，就像英文名Zhang San和中文名张三匹配起来一样。&lt;/p&gt;
&lt;p&gt;下面的static方法块的作用就是这个类在被类加载器加载时执行一次，且仅执行一次。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="https://liuyong.cc/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://liuyong.cc/tags/Java/"/>
    
      <category term="源码" scheme="https://liuyong.cc/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
</feed>
