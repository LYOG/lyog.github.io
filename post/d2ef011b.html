<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> equals与hashCode方法的联系 · Lyog's Blogs</title><meta name="description" content="equals与hashCode方法的联系 - Lyog"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="liuyong.cc/atom.xml" title="Lyog's Blogs"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Lyog's Blogs" type="application/atom+xml">
</head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">Lyog's Blogs</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>主页</p></a><a href="/archives/" target="_self" class="li component-nav-item"><p>归档</p></a><a href="/about/" target="_self" class="li component-nav-item"><p>关于我</p></a></ul></nav><!--        ul.shortcut-icons--><!--            each nav_item in theme.nav_icons--><!--                a(href=nav_item[1] target="_blank")--><!--                    img.icon(src=nav_item[0])--></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">equals与hashCode方法的联系</h1><div class="post-info">May 8, 2018</div><div class="post-content"><h3 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h3><p>equals()是用来判断其他的对象是否和该对象相等。</p>
<p>equals()在object类中定义如下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显是两个对象的地址值的比较。通常封装类有用到这个equals()时，都会对它进行重写。</p>
<p>它具有以下性质：</p>
<ul>
<li>自反性：对任意不为null的引用值x，x.equals(x)一定为true</li>
<li>对称性：对任意不为null的引用值x和y，当x.equals(y)为true时，y.equals(x)也为true</li>
<li>传递性：对任意不为null的引用值x、y、z，当x.equals(y)为true，并且y.equals(z)也为true时，x.equals(z)也为true</li>
<li>一致性：对任意不为null的引用值x和y，在对象信息没有被改的情况下，多次调用x.equals(y)结果不变</li>
</ul>
<p><strong>当equals()方法被override时，hashCode()也要被override，因为相等的对象，hashCode一定相等。</strong></p>
<a id="more"></a> 

<h3 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h3><p>hashCode()会给对象返回一个hashCode值。</p>
<p>它的性质：</p>
<ul>
<li>在一个Java应用的执行期间，如果一个对象提供给equals做比较的信息没有被修改的话，该对象多次调用hashCode方法，该方法必须始终如一返回同一个Integer。</li>
<li>如果两个对象根据equals方法是相等的，那么调用二者各自的hashCode方法必须产生同一个Integer结果。</li>
<li>并不要求根据equals(java.lang.Object)方法不相等的两个对象，调用二者各自的hashCode方法必须产生不同的integer结果。 </li>
</ul>
<h3 id="hashCode方法和equals方法的联系"><a href="#hashCode方法和equals方法的联系" class="headerlink" title="hashCode方法和equals方法的联系"></a>hashCode方法和equals方法的联系</h3><p>如何判断元素是否在HashSet中重复，过程如下：</p>
<ol>
<li>判断两个对象hashCode是否相等<ul>
<li>如果不相等，则认为两个对象也不相等</li>
<li>如果相等，进行下一步，判断equals是否相等</li>
</ul>
</li>
<li>判断两个对象equals运算是否相等<ul>
<li>如果不相等，两个对象不相等</li>
<li>如果相等，两个对象相等</li>
</ul>
</li>
</ol>
<p><strong>步骤一的作用主要是为了提高存储效率。</strong></p>
</div></article></div></div></main><footer class="footer-container"><div class="paginator"><a href="/post/5e5c5c3.html" class="prev">PREV</a><a href="/post/e6a9e5f4.html" class="next">NEXT</a></div><div class="copyright"><p>© 2017 - 2020 <a href="liuyong.cc">Lyog</a> , Powered By <a href="https://hexo.io/" target="_blank">Hexo</a>.</p></div></footer></body></html>