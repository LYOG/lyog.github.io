<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Java源码分析之Object类 · Lyog's Blogs</title><meta name="description" content="Java源码分析之Object类 - Lyog"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="https://liuyong.cc/atom.xml" title="Lyog's Blogs"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Lyog's Blogs" type="application/atom+xml">
</head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">Lyog's Blogs</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>主页</p></a><a href="/archives/" target="_self" class="li component-nav-item"><p>归档</p></a></ul></nav><!--        ul.shortcut-icons--><!--            each nav_item in theme.nav_icons--><!--                a(href=nav_item[1] target="_blank")--><!--                    img.icon(src=nav_item[0])--></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">Java源码分析之Object类</h1><div class="post-info">Dec 31, 2017</div><div class="post-content"><p>最近在研究java常见类的源码，夯实一下基础。今天先总结一下Object类。</p>
<p>Object类是java中所有类的基类，位于java.lang包中。而java.lang包又是java中最基础最核心的包，无需手动导入，编译时自动导入。</p>
<h3 id="Native方法"><a href="#Native方法" class="headerlink" title="Native方法"></a>Native方法</h3><p>在讲Object之前，先来补充一下知识点，什么是Native方法。</p>
<p>“A native method is a Java method whose implementation is provided by non-java code.”</p>
<p>简单来说就是：<strong>一个native方法是由非java语言来实现的java方法</strong>。 </p>
<p>通常情况下在定义一个native方法时，不去提供实体类，因为实体类由非java语言在外面已经实现。所以这也意味着<strong>native不能与abstract方法连用</strong>。那为什么要用Native呢，当然是因为某些高效率任务用java不易实现，而像C/C++这样的语言相对来说容易些。</p>
<hr>
<p>Object类里面没有定义属性，里面只包含13种方法。</p>
<h3 id="registerNatives"><a href="#registerNatives" class="headerlink" title="registerNatives()"></a>registerNatives()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  registerNatives();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>registerNatives()被native修饰，意味着此方法并不是在Java中实现的。</p>
<p>简单来说registerNatives()的作用是将非java语言实现的方法与java中的native方法一一对应起来，就像英文名Zhang San和中文名张三匹配起来一样。</p>
<p>下面的static方法块的作用就是这个类在被类加载器加载时执行一次，且仅执行一次。</p>
<a id="more"></a> 

<h3 id="getClass"><a href="#getClass" class="headerlink" title="getClass()"></a>getClass()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure>

<p>getClass()也是一个native方法，其作用是返回当前对象的类。等一下，类不是对象的描述嘛，对象是类的实现啊，描述也能返回吗？哈哈，看见Class&lt;?&gt;了嘛，它是描述类的类，姑且称为<strong>元类</strong>吧，实际返回的是元类的对象。</p>
<h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>也是native方法，返回的是int型的哈希码。那它的作用是什么呢？当然是为用到哈希表功能的地方行方便了。</p>
<p>有了哈希码，直接计算出地址来判断是否对象存在，就不用每次都遍历然后equals()了。</p>
<h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法用来判断<strong>两个对象的内容</strong>是否相等。常规的==判断的是内存地址是否相等。等一下，不是说判断对象不用==用equals的嘛，你不也是==实现的嘛，坑爹呢吧。哈哈，人家是可以被重写的嘛。看看String，重写成逐个char对比的。当然重写了你也<strong>别忘了重写hashCode()方法啊</strong>。为啥要重写hashCode()啊？来自成文的规定：</p>
<ul>
<li>在java应用程序执行期间，如果在equals方法比较中所用的信息没有被修改，那么在同一个对象上多次调用hashCode方法时必须一致地返回相同的整数。如果多次执行同一个应用时，不要求该整数必须相同。</li>
<li>如果两个对象通过调用equals方法是相等的，那么这两个对象调用hashCode方法必须返回相同的整数。</li>
<li>如果两个对象通过调用equals方法是不相等的，不要求这两个对象调用hashCode方法必须返回不同的整数。但是程序员应该意识到对不同的对象产生不同的hash值可以提供哈希表的性能。</li>
</ul>
<p>看到了吧，为啥两个中一个变了，另一个也要重写了吧。</p>
<h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure>
<p>又又又是native方法，克隆作用是在堆中新建一个和被克隆对象一摸一样的对象，然后返回这个新对象的地址。</p>
<p>但是有个坑要注意，对象中成员变量是基本类型好说，如果也是对象的话，成员变量的值其实可是个引用啊，被克隆回来也是个引用啊，所以那个被指向的对象内容变了，那么克隆的和被克隆对象都会被影响，这就是所谓的<strong>浅拷贝</strong>。</p>
<p>克隆就克隆，后面那throws CloneNotSupportedException是啥意思，为啥要用protected修饰。</p>
<p>这里我们要说一下protected，单protected就可以写一篇文章了。这里只说一下：<strong>当两个类不在同一个包中的时候，只能在子类内部通过子类的引用访问父类的protected属性或者方法</strong>。比如写了一个Object的子类ObjectSon，然后去另外一个包下面new ObjectSon()，这时候你是调不到ObjectSon里面的protected属性和方法的。</p>
<p>也就是说你想要在此对象外面用clone方法，必须将clone()改成public的。改成public后，它的子类或者子子孙孙类都具有clone功能了，这也不是我们想要的。所以设计者做了个开关：Cloneable接口，只有实现该接口，并且public clone()，才能在外面使用clone功能。不实现Cloneable接口报Object的CloneNotSupportedException错误。</p>
<p>要想正确使用克隆，只有通过clone()和Cloneable接口组合。</p>
<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看代码就知道返回的是对象的类型加上其哈希值，中间用@隔开。由上面equals()第三条规范可知，同一个哈希值并不一定代表同一个对象，所以toString()返回结果相同也未必会是同一个对象。</p>
<h3 id="notify"><a href="#notify" class="headerlink" title="notify()"></a>notify()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>在多线程中用到的方法，其作用是唤醒在此对象监视器上等待的单个线程。</p>
<h3 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll()"></a>notifyAll()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>同样也是多线程方法，但是它是唤醒监视器上所有等待的线程。</p>
<h3 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">      <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    timeout++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  wait(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>wait()的作用是将当前线程设为等待，直到被notify()/notifyAll()唤醒。</p>
<p>wait(long timeout)和上面相同，不过超过了参数里设定的时间后，也会自动唤醒，<strong>timeout的单位是毫秒</strong>。</p>
<p>wait(long timeout, int nanos)和wait(long timeout)的作用相同，<strong>timeout和nanos的单位是纳秒：1000000*timeout+nanos</strong>。</p>
<h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>其作用是告诉jvm，垃圾该回收了，然后就是默默等待回收就行了。因为有垃圾回收机制，通常我们不去主动调用它，除非一种情况是此<strong>对象不是由java来生成的</strong>，垃圾回收机制监管不到，只能通过主动调用告诉它该回收了。</p>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object()"></a>Object()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Object</span><span class="params">()</span></span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>默认的类构造器，不需要啥特殊解释。</p>
</div></article></div></div></main><footer class="footer-container"><div class="paginator"><a href="/post/72e3b671.html" class="prev">PREV</a><a href="/post/48d56568.html" class="next">NEXT</a></div><div class="copyright"><p>© 2017 - 2021 <a href="https://liuyong.cc">Lyog</a> , Powered By <a href="https://hexo.io/" target="_blank">Hexo</a>.</p></div></footer></body></html>