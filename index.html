<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Lyog的想当然</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="https://liuyong.cc/atom.xml" title="Lyog的想当然"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Lyog的想当然" type="application/atom+xml">
</head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">Lyog的想当然</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p class="selected">主页</p></a><a href="/archives/" target="_self" class="li component-nav-item"><p>归档</p></a></ul></nav><!--        ul.shortcut-icons--><!--            each nav_item in theme.nav_icons--><!--                a(href=nav_item[1] target="_blank")--><!--                    img.icon(src=nav_item[0])--></header><main class="container"><div id="body-container"><div id="post-list" class="left"><div class="home post-list"><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/d042904b.html" class="post-title-link">数据一致性基础理论梳理</a></h2><div class="post-info">Mar 17, 2019</div><div class="post-content"><p>趁着周末时间，把数据一致性的基础理论从头到尾梳理了一遍，真爽。</p>
<p>下面思维导图献上：</p></div><a href="/post/d042904b.html" class="read-more">READ MORE</a></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/44e620e3.html" class="post-title-link">MySQL数据库如何支持emoji表情</a></h2><div class="post-info">Jan 1, 2019</div><div class="post-content"><p>最近做的一个微信公众号的项目，有一个需求是：通过openID获取到的用户基础信息并持久化到数据库中，当时也没有多想，哐哐哐就是一通写。后来测试反馈说有些用户信息无法存储，我查了一下日志，发现类似异常：<code>java.sql.SQLException: Incorrect string value: &#39;\xF0\x9F\x92\x94&#39; for column &#39;name&#39; at row 1</code>，这才发现自己忽略了一种情况，有些用户的昵称带有emoji表情，MySQL字符集使用的uft8，只能存储3个字节的数据，但是emoji表情是4个字节，这样数据持久化的时候就必然异常。</p></div><a href="/post/44e620e3.html" class="read-more">READ MORE</a></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/e05a5fab.html" class="post-title-link">HashMap在多线程情况下还会导致死循环吗</a></h2><div class="post-info">Jun 10, 2018</div><div class="post-content"><p>先放结论，这个问题出现在JDK1.7及以前版本中，而现在JDK1.8中已经解决这个问题了。</p>
<h4 id="JDK1-7中的死循环"><a href="#JDK1-7中的死循环" class="headerlink" title="JDK1.7中的死循环"></a>JDK1.7中的死循环</h4><p>我们知道HashMap&lt;K,V&gt;存放的数据量大于了装载因子（默认75%），那么HashMap&lt;K,V&gt;就需要进行扩容操作，扩容的空间大小就是原来空间的两倍，但是扩容的时候需要rehash操作,然后赋给新的HashMap&lt;K,V&gt;。</p>
<p>JDK中需要使用resize()函数进行扩容，下面时resize()的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">        <span class="keyword">boolean</span> oldAltHashing = useAltHashing;</span><br><span class="line">        useAltHashing |= sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">                (newCapacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">        <span class="keyword">boolean</span> rehash = oldAltHashing ^ useAltHashing;</span><br><span class="line">        transfer(newTable, rehash);  <span class="comment">//transfer函数的调用</span></span><br><span class="line">        table = newTable;</span><br><span class="line">        threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在resize()这个过程中,在并发情况下也是不会出现死循环的问题，关键问题是transfer函数的调用过程。</p></div><a href="/post/e05a5fab.html" class="read-more">READ MORE</a></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/92da4c91.html" class="post-title-link">为什么wait，notify和notifyall定义在Object中</a></h2><div class="post-info">Jun 4, 2018</div><div class="post-content"><p>为什么wait，notify和notifyall定义在Object中，而不是定义在Thread类中？</p>
<ol>
<li>wait和nofity在Java中主要是实现线程之间的通信，把它们定义在Object类中，可以使任何Java对象都可以拥有实现线程通讯机制的能力。</li>
<li>每个对象都可以作为锁。</li>
<li>在Java中，为了进入临界区代码段，线程需要获得锁并且等待锁可用。它们不知道哪些线程持有锁，但是它们知道锁由哪些线程持有。它们应该等待锁而不是去查找哪个线程在代码块中去要求它们释放锁。</li>
</ol></div><a href="/post/92da4c91.html" class="read-more">READ MORE</a></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/62504291.html" class="post-title-link">Cookie与Session的区别</a></h2><div class="post-info">Jun 3, 2018</div><div class="post-content"><h4 id="Cookie机制"><a href="#Cookie机制" class="headerlink" title="Cookie机制"></a>Cookie机制</h4><p>Cookies是服务器在本地机器上存储的小段文字并随每一个请求发送至同一个服务器。网络服务器用HTTP头向客户端发送Cookies，在客户端，浏览器解析这些Cookies并将它们保存为一个本地文件，它会自动将同一服务器的任何请求缚上这些Cookies。</p>
<p>具体来说Cookie机制采取的是<strong>在客户端保持状态</strong>的方案。它需要用户打开客户端的Cookie支持，它的作用就是为了<strong>解决HTTP协议无状态</strong>的缺陷。</p>
<p><strong>Cookie的内容主要包括：名字、值、过期时间、路径和域。</strong></p>
<p>路径和域一起构成Cookie的作用范围。</p>
<p>若不设置范围，则Cookie的生命周期为浏览器会话状态期间，关闭浏览器，Cookie就消失。这种Cookie称为会话Cookie，通常保存在内存中。而设置了过期时间的Cookie会被保存至硬盘。</p>
<h4 id="Session机制"><a href="#Session机制" class="headerlink" title="Session机制"></a>Session机制</h4><p>Session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构来保存信息。</p>
<p>当程序需要为某个客户端的请求创建一个Session时，服务器首先检查这个客户端里知否已经包含一个Session标识，如果包含则按照Session ID来把这个Session检索出来，检索不到的话会新建一个。</p>
<p>如果客户端请求不包含Session ID，则为此客户端创建一个Session并生成一个与此Session相关联的Session ID，这个Session ID将在本次响应中返回给客户端。</p>
<p>保存这个Session ID的方式可以采用Cookie，但如果Cookie被人禁止的话，就必须使用其它机制来传递Session ID。通常使用的一种技术叫做URL重写，就是把Session ID直接附加在URL路径后面；还有一种技术叫做表单隐藏字段，就是服务器会自动修改表单，添加一个隐藏字段，以便表单提交时能欧巴Session ID传回给服务器。</p></div><a href="/post/62504291.html" class="read-more">READ MORE</a></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/b0ac8d7a.html" class="post-title-link">HTTP中Get请求与Post请求的区别</a></h2><div class="post-info">Jun 1, 2018</div><div class="post-content"><h3 id="GET和POST长度的限制问题"><a href="#GET和POST长度的限制问题" class="headerlink" title="GET和POST长度的限制问题"></a>GET和POST长度的限制问题</h3><p><strong>GET</strong></p>
<ul>
<li>GET是通过URL提交数据，因此GET可提交的数据量就跟URL所能达到的最大长度有直接关系</li>
<li>实际上HTTP协议对URL长度是没有限制的；限制URL长度大多数是浏览器或者服务器的配置参数</li>
</ul>
<p><strong>POST</strong></p>
<ul>
<li>HTTP协议没有对POST进行任何限制，一般是受服务器配置限制或者内存大小</li>
</ul>
<h3 id="GET和POST的安全性"><a href="#GET和POST的安全性" class="headerlink" title="GET和POST的安全性"></a>GET和POST的安全性</h3><p>GET是通过URL方式请求，可以直接看到，明文传输。 </p>
<p>POST是通过请求header请求，可以开发者工具或者抓包可以看到，同样也是明文的。</p>
<p>GET请求会保存在浏览器历史纪录中，还可能会保存在Web的日志中。</p>
<h3 id="GET和POST对服务器的状态"><a href="#GET和POST对服务器的状态" class="headerlink" title="GET和POST对服务器的状态"></a>GET和POST对服务器的状态</h3><p>根据http的设计，大家在看到get的时候，都期望这个请求对服务器没有修改，看到post的时候，都认为这对服务器产生了修改。 </p></div><a href="/post/b0ac8d7a.html" class="read-more">READ MORE</a></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/5e5c5c3.html" class="post-title-link">Java序列化与反序列化</a></h2><div class="post-info">May 18, 2018</div><div class="post-content"><h3 id="序列化的作用"><a href="#序列化的作用" class="headerlink" title="序列化的作用"></a>序列化的作用</h3><p>Java平台允许我们在内存中创建可复用的Java对象，但一般情况下，只有当JVM处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比JVM的生命周期更长。但在现实应用中，就可能要求在JVM停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。Java对象序列化就能够帮助我们实现该功能。</p>
<p>使用Java对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装成对象。必须注意地是，对象序列化保存的是对象的”状态”，即它的成员变量。由此可知，<strong>对象序列化不会关注类中的静态变量</strong>。</p>
<p>除了在持久化对象时会用到对象序列化之外，当使用RMI(远程方法调用)，或在网络中传递对象时，都会用到对象序列化。</p></div><a href="/post/5e5c5c3.html" class="read-more">READ MORE</a></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/d2ef011b.html" class="post-title-link">equals与hashCode方法的联系</a></h2><div class="post-info">May 8, 2018</div><div class="post-content"><h3 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h3><p>equals()是用来判断其他的对象是否和该对象相等。</p>
<p>equals()在object类中定义如下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显是两个对象的地址值的比较。通常封装类有用到这个equals()时，都会对它进行重写。</p>
<p>它具有以下性质：</p>
<ul>
<li>自反性：对任意不为null的引用值x，x.equals(x)一定为true</li>
<li>对称性：对任意不为null的引用值x和y，当x.equals(y)为true时，y.equals(x)也为true</li>
<li>传递性：对任意不为null的引用值x、y、z，当x.equals(y)为true，并且y.equals(z)也为true时，x.equals(z)也为true</li>
<li>一致性：对任意不为null的引用值x和y，在对象信息没有被改的情况下，多次调用x.equals(y)结果不变</li>
</ul>
<p><strong>当equals()方法被override时，hashCode()也要被override，因为相等的对象，hashCode一定相等。</strong></p></div><a href="/post/d2ef011b.html" class="read-more">READ MORE</a></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/e6a9e5f4.html" class="post-title-link">二维码纠错原理</a></h2><div class="post-info">May 1, 2018</div><div class="post-content"><p>前言：今天坐车的时候看到座位上有个被污染二维码，然后发现依然被识别，心里纳闷这二维码究竟是一个什么纠错原理？</p>
<h3 id="Reed-solomon-codes"><a href="#Reed-solomon-codes" class="headerlink" title="Reed-solomon codes"></a>Reed-solomon codes</h3><p>在网上搜寻一番，发现二维码通过RS码进行纠错。关于RS码，维基百科是这么定义的：</p>
<blockquote>
<p>里德-所罗门码（里所码，Reed-solomon codes，简称RS codes）是一种前向错误更正的信道编码，对由校正过采样数据所产生的有效多项式。编码过程首先在多个点上对这些多项式求冗余，然后将其传输或者存储。对多项式的这种超出必要值得采样使得多项式超定（过限定）。当接收器正确的收到足够的点后，它就可以恢复原来的多项式，即使接收到的多项式上有很多点被噪声干扰失真。</p>
</blockquote>
<p>好了，说人话：任意k个确定点可以表示一个阶数至少为k-1的多项式，比如我们只需要16个点就可以确定这个多项式，但是可以发送25个点的数据，所以我们可以在其它点对这个多项式求冗余，哪怕25个点里有几个点缺失了，也可以通过剩余的点去反推出最初的多项式。</p></div><a href="/post/e6a9e5f4.html" class="read-more">READ MORE</a></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/post/3e6ff0a8.html" class="post-title-link">抽象类和接口的区别</a></h2><div class="post-info">Apr 2, 2018</div><div class="post-content"><h3 id="抽象类（abstract-class）"><a href="#抽象类（abstract-class）" class="headerlink" title="抽象类（abstract class）"></a>抽象类（abstract class）</h3><p>定义：如果一个类没有包含足够多的信息来描述一个具体的对象，这样的类就是抽象类。 使用abstract来修饰。</p>
<p>特点：</p>
<ul>
<li>不能实例化 ，只能被继承</li>
<li>被abstract修饰的方法 ，只声明，不实现</li>
<li>含有含有抽象方法 的类必须为抽象类</li>
</ul></div><a href="/post/3e6ff0a8.html" class="read-more">READ MORE</a></article></div></div></div><div id="sidebar" class="left"><div id="about-panel"><div class="info"><div class="title">盒子</div><div class="url">https://liuyong.cc</div><div class="bio">我想出门晒太阳</div></div><img src="/images/avatar.png" class="avatar"></div><div id="friend-links-panel"><div class="panel-title"><p>LINKS</p></div><a href="https://liuyong.cc/about/" target="_blank" class="link-item"><div class="link-container"><div class="site-name">关于我</div><div class="site-desc"></div></div></a></div></div></div><div class="clear"></div></main><footer class="footer-container"><div class="paginator"><a href="/page/2/" class="next">NEXT</a></div><div class="copyright"><p>© 2017 - 2021 <a href="https://liuyong.cc">Lyog</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p></div></footer></body></html>