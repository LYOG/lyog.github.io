<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Java序列化与反序列化 · 盒子</title><meta name="description" content="Java序列化与反序列化 - Liu Yong"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="https://liuyong.cc/atom.xml" title="盒子"></head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">盒子</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>现在</p></a><a href="/archives" target="_self" class="li component-nav-item"><p>过去</p></a><a href="/about" target="_self" class="li component-nav-item"><p>关于</p></a></ul></nav><!--        ul.shortcut-icons--><!--            each nav_item in theme.nav_icons--><!--                a(href=nav_item[1] target="_blank")--><!--                    img.icon(src=nav_item[0])--></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">Java序列化与反序列化</h1><div class="post-info">May 18, 2018</div><div class="post-content"><h3 id="序列化的作用"><a href="#序列化的作用" class="headerlink" title="序列化的作用"></a>序列化的作用</h3><p>Java平台允许我们在内存中创建可复用的Java对象，但一般情况下，只有当JVM处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比JVM的生命周期更长。但在现实应用中，就可能要求在JVM停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。Java对象序列化就能够帮助我们实现该功能。</p>
<p>使用Java对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装成对象。必须注意地是，对象序列化保存的是对象的”状态”，即它的成员变量。由此可知，<strong>对象序列化不会关注类中的静态变量</strong>。</p>
<p>除了在持久化对象时会用到对象序列化之外，当使用RMI(远程方法调用)，或在网络中传递对象时，都会用到对象序列化。</p>
<a id="more"></a> 
<h3 id="序列化与反序列化的特性"><a href="#序列化与反序列化的特性" class="headerlink" title="序列化与反序列化的特性"></a>序列化与反序列化的特性</h3><ol>
<li>在Java中，只要一个类实现了<code>java.io.Serializable</code>接口，那么它就可以被序列化。 </li>
<li>通过<code>ObjectOutputStream</code>和<code>ObjectInputStream</code>对对象进行序列化及反序列化。</li>
<li>虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 <code>private static final long serialVersionUID</code>）。</li>
<li>序列化并不保存静态变量。 </li>
<li>要想将父类对象也序列化，就需要让父类也实现<code>Serializable</code> 接口。 </li>
<li>Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。 </li>
<li>服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。  </li>
</ol>
</div></article></div></div></main><footer class="footer-container"><div class="paginator"><a href="/2018/06/01/HTTP中Get请求与Post请求的区别/" class="prev">PREV</a><a href="/2018/05/08/equals与hashCode方法的联系/" class="next">NEXT</a></div><div class="copyright"><p>© 2017 - 2019 <a href="https://liuyong.cc">Liu Yong</a> , Powered By <a href="https://hexo.io/" target="_blank">Hexo</a>.</p></div></footer></body></html>