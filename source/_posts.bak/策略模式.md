---
title: 策略模式
tags:
  - 设计模式
categories: 设计模式
abbrlink: 72e3b671
date: 2018-01-04 22:54:03
---

策略模式在《Head First 设计模式》中的定义如下：

**策略模式定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。**

我们日常开发中会在什么时候用到此模式呢？
1. 几个类的主要逻辑相同，只在部分逻辑的算法和行为上稍有区别的情况
2. 有几种相似的行为或算法，需要动态地决定使用哪一种

具体如何使用策略模式，让我们举个《Head First 设计模式》中的例子:

<!-- more --> 

*假设有一个模拟鸭子的游戏，游戏中会出现各种鸭子，一边游泳戏水，一边呱呱叫。这个游戏的内部设计了一个鸭子超类Duck，并让各种鸭子继承此超类。*

*现在有个新的功能：让部分鸭子能飞*

我们先来实现超类Duck，然后进行问题分析。

```java
public abstract class Duck {
    public void quack(){
        // 所有的鸭子都会呱呱叫，由Duck类负责实现
    }
    public void swim(){
        // 所有的鸭子都会游泳，由Duck类负责实现
    }
    public abstract void display();  // 每个鸭子的子类负责实现自己的display
}
```

具体分析如下：
1. 我们是否可以直接在Duck里面添加fly()方法，答案是否，这样的话所有继承Duck的子类都会有fly()方法，橡皮鸭继承自Duck，但是它不会飞，却具有fly()方法。
2. 我们是否可以定义一个Flyable接口，让Duck的子类来实现。同样是否，比如小白鸭和小黄鸭分别是Duck的子类，它们具有相同的飞行行为，但却各自实现一遍Flyable接口，代码复用性太低。
3. 我们是不是可以写个FlyBehavior接口，然后实现其子类：
   1. FlyWithWings继承自FlyBehavior，实现鸭子正常飞行；
   2. FlyNoWay继承自FlyBehavior，实现不会飞的鸭子的行为；
   3. FlyRocketPowered继承自FlyBehavior，实现鸭子火箭般飞行；

让我们来看具体代码：

```java
public abstract class Duck {
	//---------------------
    FlyBehavior flyBehavior;
    
    public void performFly(){
        flyBehavior.fly();
    }
    
    public void setFlyBehavior(FlyBehavior flyBehavior){
        this.flyBehavior = flyBehavior;
    }
	//---------------------
	
    public Duck(){
    }

    public abstract void display();

    public void swim(){
        System.out.println("All ducks float, even decoys!");
    }
}

public class MallardDuck extends Duck {
    public MallardDuck(){
        flyBehavior = new FlyWithWings();
    }

    public void display() {
        System.out.println("I'm a real Mallard duck");
    }
}

public interface FlyBehavior {
    public void fly();
}

public class FlyWithWings implements FlyBehavior {
    public void fly(){
        System.out.println("I'm flying!!");
    }
}

public class FlyNoWay implements FlyBehavior {
    public void fly(){
        System.out.println("I can't fly");
    }
}

public class FlyRocketPowered implements FlyBehavior {
    public void fly(){
        System.out.println("I'm flying with a rocket!");
    }
}

// 测试类
public class DuckTest{
    public static void main(String[] args){
        Duck mallard = new MallardDuck();
        mallard.performFly();
        mallard.setFlyBehavior(new FlyRocketPowered());
        mallard.performFly();
    }
}
```

从代码可以看出策略模式的结构：
- 环境类：负责对策略进行二次封装。（Duck类）
- 抽象策略类：当各个实现类中存在着重复的逻辑时，则使用抽象类来封装这部分公共的代码。（FlyBehavior接口）
- 具体策略类：由一组封装了算法或行为的类来担任，这些类之间可以根据需要自由替换。（FlyWithWings类、FlyNoWay类、FlyRocketPowered类）

策略模式的优点：
* 策略类之间可以自由切换
* 易于扩展，方便添加修改策略类
* 避免使用多重条件，若没有策略模式，需要添加许多判断条件进行判断使用哪一种算法

策略模式的缺点：
* 必须知道所有的策略类，并自行决定使用哪一个策略类
* 可能会产生过多策略类，也不容易维护，这时候需要享元模式减少策略类数量。