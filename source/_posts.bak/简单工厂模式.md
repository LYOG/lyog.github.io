---
title: 简单工厂模式
tags:
  - 设计模式
categories: 设计模式
abbrlink: 6b3bea20
date: 2018-03-26 21:23:18
---
简单工厂模式又称为静态工厂方法模式，定义一个专门的类来创建其它类的实例，根据传入参数的不同，创建的类的实例不同，但它们都有一个共同的父类。

我们正常使用JDBC如下所示：
```java
Connection connection = ...
Statement statement = connection.createStatement();
ResultSet resultSet = statement.executeQuery("SELECT * FROM MYTABLE");
while (resultSet.next()) {
    //数据处理
}
statement.close();
connection.close();
```
<!-- more --> 

如果使用简单工厂模式进行连接不同的数据库，就是如下形式：

```java
public class ConnectionFactory {
    public static Connection create(String type, Properties info) {
        if ("mysql".equals(type)) {
            return new MySqlConnection(info);
        } else if ("oracle".equals(type)) {
            return new OracleConnection(info);
        } else if ("db2".equals(type)) {
            return new DB2Connection(info);
        } else {
            throw new RuntimeErrorException(null, "unsupported db type =" + type);
        }

    }
}
```

上面写法比较笨重，打成jar包后无法修改，不符合开闭原则，可以通过反射和配置文件增加灵活性。代码如下：
```java
public class ConnectionFactory2 {
    public static Connection create(String type, Properties info) {

        Class<?> clz = getConnectionClass(type);
        try {
            Constructor<?> constructor = clz.getConstructor(Properties.class);
            return (Connection) constructor.newInstance(info);
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException("unsupported db type =" + type);
        }
    }

    public static Class getConnectionClass(String type) {

        // 实现略
        return null;
    }
}
```
下面来总结一下简单工厂模式的特点。
**结构：**
![简单工厂模式UML图][1]
**优点：**
1. 通过工厂，客户端免于创建对象的责任，只需要负责消费对象即可。
2. 利用对象多态性和里氏代换原则，在运行时子类覆盖父类对象，易于扩展。

**缺点：**
1. 对扩展开放，对修改也开放，不符合开闭原则（通过反射可消除此问题）。
2. 当产品种类庞大之后，难以进行维护。

**在JDK中的应用：**
```java
//DateFormat中的应用
public abstract class DateFormat extends Format {

    //其它省略
    private static DateFormat get(LocaleProviderAdapter adapter, int timeStyle, int dateStyle, Locale loc) {
        DateFormatProvider provider = adapter.getDateFormatProvider();
        DateFormat dateFormat;
        if (timeStyle == -1) {
            dateFormat = provider.getDateInstance(dateStyle, loc);
        } else {
            if (dateStyle == -1) {
                dateFormat = provider.getTimeInstance(timeStyle, loc);
            } else {
                dateFormat = provider.getDateTimeInstance(dateStyle, timeStyle, loc);
            }
        }
        return dateFormat;
    }
}
```


[1]: https://ws1.sinaimg.cn/large/80854ce7ly1fpqiqdxt9ij20rn09t0st.jpg