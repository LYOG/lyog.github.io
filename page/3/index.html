<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 盒子</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="https://www.liuyong.cc/atom.xml" title="盒子"></head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">盒子</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>现在</p></a><a href="/archives" target="_self" class="li component-nav-item"><p>过去</p></a><ul class="shortcut-icons"><a href="https://github.com/AngryPowman" target="_blank"><img src="/images/github.svg" class="icon"></a><a href="/atom.xml" target="_blank"><img src="/images/rss.svg" class="icon"></a></ul></ul></nav></header><main class="container"><div id="body-container"><div id="post-list" class="left"><div class="home post-list"><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/03/27/工厂模式/" class="post-title-link">工厂模式</a></h2><div class="post-info">Mar 27, 2018</div><div class="post-content"><p>工厂模式是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。这样做的好处是核心工厂类不在负责产品的创建，只负责具体工厂子类需要实现的接口。增加新的产品时不会对原有的工厂进行修改。<br>同简单工厂模式一样，我们用JDBC举例子。<br>我们正常使用JDBC如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Connection connection = ...</span><br><span class="line">Statement statement = connection.createStatement();</span><br><span class="line">ResultSet resultSet = statement.executeQuery(<span class="string">"SELECT * FROM MYTABLE"</span>);</span><br><span class="line"><span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">    <span class="comment">//数据处理</span></span><br><span class="line">&#125;</span><br><span class="line">statement.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure></p></div><a href="/2018/03/27/工厂模式/" class="read-more">READ MORE</a></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/03/26/简单工厂模式/" class="post-title-link">简单工厂模式</a></h2><div class="post-info">Mar 26, 2018</div><div class="post-content"><p>简单工厂模式又称为静态工厂方法模式，定义一个专门的类来创建其它类的实例，根据传入参数的不同，创建的类的实例不同，但它们都有一个共同的父类。</p>
<p>我们正常使用JDBC如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Connection connection = ...</span><br><span class="line">Statement statement = connection.createStatement();</span><br><span class="line">ResultSet resultSet = statement.executeQuery(<span class="string">"SELECT * FROM MYTABLE"</span>);</span><br><span class="line"><span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">    <span class="comment">//数据处理</span></span><br><span class="line">&#125;</span><br><span class="line">statement.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure></p></div><a href="/2018/03/26/简单工厂模式/" class="read-more">READ MORE</a></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/03/25/Java虚拟机内存区域划分/" class="post-title-link">Java虚拟机内存区域划分</a></h2><div class="post-info">Mar 25, 2018</div><div class="post-content"><p>java虚拟机的主要作用是加载并执行class文件。而在执行class文件中，如何存放class中的代码？运行过程中会生成大量的对象，这些对象如何存储？同时在执行过程中如何保存执行状态？其实都保存在Java内存区域中，而如何合理的划分这个区域，是我们关注的重点。<br>根据《Java虚拟机规范》的规定，Java虚拟机所管理的内存将分成如下几个运行时数据区域。</p>
<p></p></div><a href="/2018/03/25/Java虚拟机内存区域划分/" class="read-more">READ MORE</a></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/03/15/Java中的装箱和拆箱/" class="post-title-link">Java中的装箱和拆箱</a></h2><div class="post-info">Mar 15, 2018</div><div class="post-content"><h3 id="一、什么是装箱？什么是拆箱？"><a href="#一、什么是装箱？什么是拆箱？" class="headerlink" title="一、什么是装箱？什么是拆箱？"></a>一、什么是装箱？什么是拆箱？</h3><p>Java为每种基本数据类型都提供了对应的包装器类型 ，基本类型到包装器类型之间的转换就是装箱和拆箱。</p>
<ul>
<li>装箱：自动将基本数据类型转换为包装器类型</li>
<li>拆箱：自动将包装器类型转换为基本数据类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="keyword">int</span> n = i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装器类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>int（4字节）</td>
<td>Integer</td>
</tr>
<tr>
<td>byte（1字节）</td>
<td>Byte</td>
</tr>
<tr>
<td>short（2字节）</td>
<td>Short</td>
</tr>
<tr>
<td>long（8字节）</td>
<td>Long</td>
</tr>
<tr>
<td>float（4字节）</td>
<td>Float</td>
</tr>
<tr>
<td>double（8字节）</td>
<td>Double</td>
</tr>
<tr>
<td>char（2字节）</td>
<td>Character</td>
</tr>
<tr>
<td>boolean（未定）</td>
<td>Boolean</td>
</tr>
</tbody>
</table></div><a href="/2018/03/15/Java中的装箱和拆箱/" class="read-more">READ MORE</a></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/03/10/Java对象的初始化顺序/" class="post-title-link">Java对象的初始化顺序</a></h2><div class="post-info">Mar 10, 2018</div><div class="post-content"></div><a href="/2018/03/10/Java对象的初始化顺序/" class="read-more">READ MORE</a></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/03/09/Java运行时异常与一般异常有何异同/" class="post-title-link">Java运行时异常与一般异常有何异同</a></h2><div class="post-info">Mar 9, 2018</div><div class="post-content"></div><a href="/2018/03/09/Java运行时异常与一般异常有何异同/" class="read-more">READ MORE</a></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/03/07/String-StringBuffer-StringBuilder的区别/" class="post-title-link">String、StringBuffer、StringBuilder的区别</a></h2><div class="post-info">Mar 7, 2018</div><div class="post-content"></div><a href="/2018/03/07/String-StringBuffer-StringBuilder的区别/" class="read-more">READ MORE</a></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/03/03/Java中的继承-封装-多态/" class="post-title-link">Java中的继承、封装、多态</a></h2><div class="post-info">Mar 3, 2018</div><div class="post-content"></div><a href="/2018/03/03/Java中的继承-封装-多态/" class="read-more">READ MORE</a></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/01/04/策略模式/" class="post-title-link">策略模式</a></h2><div class="post-info">Jan 4, 2018</div><div class="post-content"><p>策略模式在《Head First 设计模式》中的定义如下：</p>
<p><strong>策略模式定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。</strong></p>
<p>我们日常开发中会在什么时候用到此模式呢？</p>
<ol>
<li>几个类的主要逻辑相同，只在部分逻辑的算法和行为上稍有区别的情况</li>
<li>有几种相似的行为或算法，需要动态地决定使用哪一种</li>
</ol>
<p>具体如何使用策略模式，让我们举个《Head First 设计模式》中的例子:</p></div><a href="/2018/01/04/策略模式/" class="read-more">READ MORE</a></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/12/31/Java源码分析之Object类/" class="post-title-link">Java源码分析之Object类</a></h2><div class="post-info">Dec 31, 2017</div><div class="post-content"><p>最近在研究java常见类的源码，夯实一下基础。今天先总结一下Object类。</p>
<p>Object类是java中所有类的基类，位于java.lang包中。而java.lang包又是java中最基础最核心的包，无需手动导入，编译时自动导入。</p>
<h3 id="Native方法"><a href="#Native方法" class="headerlink" title="Native方法"></a>Native方法</h3><p>在讲Object之前，先来补充一下知识点，什么是Native方法。</p>
<p>“A native method is a Java method whose implementation is provided by non-java code.”</p>
<p>简单来说就是：<strong>一个native方法是由非java语言来实现的java方法</strong>。 </p>
<p>通常情况下在定义一个native方法时，不去提供实体类，因为实体类由非java语言在外面已经实现。所以这也意味着<strong>native不能与abstract方法连用</strong>。那为什么要用Native呢，当然是因为某些高效率任务用java不易实现，而像C/C++这样的语言相对来说容易些。</p>
<hr>
<p>Object类里面没有定义属性，里面只包含13种方法。</p>
<h3 id="registerNatives"><a href="#registerNatives" class="headerlink" title="registerNatives()"></a>registerNatives()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  registerNatives();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>registerNatives()被native修饰，意味着此方法并不是在Java中实现的。</p>
<p>简单来说registerNatives()的作用是将非java语言实现的方法与java中的native方法一一对应起来，就像英文名Zhang San和中文名张三匹配起来一样。</p>
<p>下面的static方法块的作用就是这个类在被类加载器加载时执行一次，且仅执行一次。</p></div><a href="/2017/12/31/Java源码分析之Object类/" class="read-more">READ MORE</a></article></div></div></div><div id="sidebar" class="left"><div id="about-panel"><div class="info"><div class="title">Liu Yong</div><div class="url">https://www.liuyong.cc</div><div class="bio">我想出门晒太阳</div></div><img src="/images/avatar.jpg" class="avatar"></div><div id="friend-links-panel"><div class="panel-title"><p>LINKS</p></div><a href="http://www.liuyong.cc/about" target="_blank" class="link-item"><div class="link-container"><div class="site-name">关于我</div><div class="site-desc">http://www.liuyong.cc/about</div></div></a><a href="http://powman.org" target="_blank" class="link-item"><div class="link-container"><div class="site-name">Demo Links</div><div class="site-desc">You can change this in your theme config</div></div></a></div></div></div><div class="clear"></div></main><footer class="footer-container"><div class="paginator"><a href="/page/2/" class="prev">PREV</a><a href="/page/4/" class="next">NEXT</a></div><div class="copyright"><p>© 2016 - 2018 <a href="https://www.liuyong.cc">Liu Yong</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p></div></footer></body></html>