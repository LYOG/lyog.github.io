<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 盒子</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="https://liuyong.cc/atom.xml" title="盒子"></head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">盒子</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>现在</p></a><a href="/archives" target="_self" class="li component-nav-item"><p>过去</p></a><a href="/about" target="_self" class="li component-nav-item"><p>关于</p></a></ul></nav><!--        ul.shortcut-icons--><!--            each nav_item in theme.nav_icons--><!--                a(href=nav_item[1] target="_blank")--><!--                    img.icon(src=nav_item[0])--></header><main class="container"><div id="body-container"><div id="post-list" class="left"><div class="home post-list"><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/03/27/工厂模式/" class="post-title-link">工厂模式</a></h2><div class="post-info">Mar 27, 2018</div><div class="post-content"><p>工厂模式是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。这样做的好处是核心工厂类不在负责产品的创建，只负责具体工厂子类需要实现的接口。增加新的产品时不会对原有的工厂进行修改。<br>同简单工厂模式一样，我们用JDBC举例子。<br>我们正常使用JDBC如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Connection connection = ...</span><br><span class="line">Statement statement = connection.createStatement();</span><br><span class="line">ResultSet resultSet = statement.executeQuery(<span class="string">"SELECT * FROM MYTABLE"</span>);</span><br><span class="line"><span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">    <span class="comment">//数据处理</span></span><br><span class="line">&#125;</span><br><span class="line">statement.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure></p></div><a href="/2018/03/27/工厂模式/" class="read-more">READ MORE</a></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/03/26/简单工厂模式/" class="post-title-link">简单工厂模式</a></h2><div class="post-info">Mar 26, 2018</div><div class="post-content"><p>简单工厂模式又称为静态工厂方法模式，定义一个专门的类来创建其它类的实例，根据传入参数的不同，创建的类的实例不同，但它们都有一个共同的父类。</p>
<p>我们正常使用JDBC如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Connection connection = ...</span><br><span class="line">Statement statement = connection.createStatement();</span><br><span class="line">ResultSet resultSet = statement.executeQuery(<span class="string">"SELECT * FROM MYTABLE"</span>);</span><br><span class="line"><span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">    <span class="comment">//数据处理</span></span><br><span class="line">&#125;</span><br><span class="line">statement.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure></p></div><a href="/2018/03/26/简单工厂模式/" class="read-more">READ MORE</a></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/03/25/Java虚拟机内存区域划分/" class="post-title-link">Java虚拟机内存区域划分</a></h2><div class="post-info">Mar 25, 2018</div><div class="post-content"><p>java虚拟机的主要作用是加载并执行class文件。而在执行class文件中，如何存放class中的代码？运行过程中会生成大量的对象，这些对象如何存储？同时在执行过程中如何保存执行状态？其实都保存在Java内存区域中，而如何合理的划分这个区域，是我们关注的重点。<br>根据《Java虚拟机规范》的规定，Java虚拟机所管理的内存将分成如下几个运行时数据区域。</p>
<p></p></div><a href="/2018/03/25/Java虚拟机内存区域划分/" class="read-more">READ MORE</a></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/03/15/Java中的装箱和拆箱/" class="post-title-link">Java中的装箱和拆箱</a></h2><div class="post-info">Mar 15, 2018</div><div class="post-content"><h3 id="一、什么是装箱？什么是拆箱？"><a href="#一、什么是装箱？什么是拆箱？" class="headerlink" title="一、什么是装箱？什么是拆箱？"></a>一、什么是装箱？什么是拆箱？</h3><p>Java为每种基本数据类型都提供了对应的包装器类型 ，基本类型到包装器类型之间的转换就是装箱和拆箱。</p>
<ul>
<li>装箱：自动将基本数据类型转换为包装器类型</li>
<li>拆箱：自动将包装器类型转换为基本数据类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="keyword">int</span> n = i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装器类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>int（4字节）</td>
<td>Integer</td>
</tr>
<tr>
<td>byte（1字节）</td>
<td>Byte</td>
</tr>
<tr>
<td>short（2字节）</td>
<td>Short</td>
</tr>
<tr>
<td>long（8字节）</td>
<td>Long</td>
</tr>
<tr>
<td>float（4字节）</td>
<td>Float</td>
</tr>
<tr>
<td>double（8字节）</td>
<td>Double</td>
</tr>
<tr>
<td>char（2字节）</td>
<td>Character</td>
</tr>
<tr>
<td>boolean（未定）</td>
<td>Boolean</td>
</tr>
</tbody>
</table></div><a href="/2018/03/15/Java中的装箱和拆箱/" class="read-more">READ MORE</a></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/03/10/Java对象的初始化顺序/" class="post-title-link">Java对象的初始化顺序</a></h2><div class="post-info">Mar 10, 2018</div><div class="post-content"><p>加载类</p>
<ol>
<li>为父类静态属性分配内存并赋值 / 执行父类静态代码段 （按代码顺序）</li>
<li>为子类静态属性分配内存并赋值 / 执行子类静态代码段 （按代码顺序）</li>
</ol></div><a href="/2018/03/10/Java对象的初始化顺序/" class="read-more">READ MORE</a></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/03/09/Java运行时异常与一般异常有何异同/" class="post-title-link">Java运行时异常与一般异常有何异同</a></h2><div class="post-info">Mar 9, 2018</div><div class="post-content"><p>Throwable是所有Java程序中错误处理的父类，有两种资类：Error和Exception。</p>
<ul>
<li>Error：表示由JVM所侦测到的无法预期的错误，由于这是属于JVM层次的严重错误，导致JVM无法继续执行，因此，这是不可捕捉到的，无法采取任何恢复的操作，顶多只能显示错误信息。</li>
<li>Exception：表示可恢复的例外，这是可捕捉到的。 </li>
</ul>
<p>Java提供了两类主要的异常:runtime exception和checked exception </p>
<ul>
<li>checked 异常也就是我们经常遇到的IO异常，以及SQL异常都是这种异常。对于这种异常，JAVA编译器强制要求我们必需对出现的这些异常进行catch。这类异常一般是外部错误,例如试图从文件尾后读取数据等,这并不是程序本身的错误,而是在应用环境中出现的外部错误 。</li>
<li>runtime exception，也称运行时异常，我们可以不处理。当出现这样的异常时，总是由虚拟机接管。出现运行时异常后，系统会把异常一直往上层抛，一直遇到处理代码。如果没有处理块，到最上层，如果是多线程就由Thread.run()抛出，如果是单线程就被main()抛出。抛出之后，如果是线程，这个线程也就退出了。如果是主程序抛出的异常，那么这整个程序也就退出了 。</li>
</ul></div><a href="/2018/03/09/Java运行时异常与一般异常有何异同/" class="read-more">READ MORE</a></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/03/07/String-StringBuffer-StringBuilder的区别/" class="post-title-link">String、StringBuffer、StringBuilder的区别</a></h2><div class="post-info">Mar 7, 2018</div><div class="post-content"><h3 id="一、-字符串的不变性"><a href="#一、-字符串的不变性" class="headerlink" title="一、 字符串的不变性"></a>一、 字符串的不变性</h3><p>String 字符串的不变性：<strong>String 对象创建后则不能被修改，是不可变的</strong>。  </p>
<p>下面看看 String 不变性的原因</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The value is used for character storage. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The offset is the first index of the storage that is used. *</span></span><br><span class="line"><span class="comment">private final int offset;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/** The count is the number of characters in the String. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure>
<p>用于存放字符的数组被声明为final的，因此只能赋值一次，不可再更改。</p>
<p>重新赋值修改字符串<strong>其实是创建了新的对象，所指向的内存空间不同</strong>。  </p>
<h3 id="二、-StringBuffer和StringBuilder介绍"><a href="#二、-StringBuffer和StringBuilder介绍" class="headerlink" title="二、 StringBuffer和StringBuilder介绍"></a>二、 StringBuffer和StringBuilder介绍</h3><p>StringBuilder：字符串变量（非线程安全）。在内部，StringBuilder对象被当作是一个包含字符序列的变长数组。</p>
<p>StringBuffer：字符串变量（Synchronized，即线程安全）。StringBuffer的线程安全，仅仅是保证jvm不抛出异常顺利的往下执行而已，它不保证逻辑正确和调用顺序正确。大多数时候，我们需要的不仅仅是线程安全，而是锁。</p></div><a href="/2018/03/07/String-StringBuffer-StringBuilder的区别/" class="read-more">READ MORE</a></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/03/03/Java中的继承-封装-多态/" class="post-title-link">Java中的继承、封装、多态</a></h2><div class="post-info">Mar 3, 2018</div><div class="post-content"><h3 id="一、继承"><a href="#一、继承" class="headerlink" title="一、继承"></a>一、继承</h3><ul>
<li>Java只支持单继承，不支持多重继承</li>
<li>Java 中用关键字extends 来实现单继承</li>
<li>构造方法不能被继承 </li>
<li>不能继承私有属性与方法</li>
</ul>
<h3 id="二、封装"><a href="#二、封装" class="headerlink" title="二、封装"></a>二、封装</h3><p>封装是Java面向对象的特点的表现，即把对象的全部属性和全部服务结合在一起，形成一个不可分割的独立单位，同时尽可能隐藏对象的内部结构。</p>
<p>在Java中是通过各种访问限定符来实现数据封装的，共分为四种访问级别(由高到低)：</p>
<ul>
<li>public(公共) ：可以在任何地方(指的是任何包中)的任何类中被访问</li>
<li>protected(受保护的) ：可以在同包中的任何类、不同包中的任何当前类的子类中所访问</li>
<li>friendly(缺省的) ：只能在同包的类中访问</li>
<li>private(私有的) ：只能在当前类中被访问</li>
</ul>
<p><strong>类只可以定义为默认或公共级别(嵌套类除外)。</strong> </p></div><a href="/2018/03/03/Java中的继承-封装-多态/" class="read-more">READ MORE</a></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/01/04/策略模式/" class="post-title-link">策略模式</a></h2><div class="post-info">Jan 4, 2018</div><div class="post-content"><p>策略模式在《Head First 设计模式》中的定义如下：</p>
<p><strong>策略模式定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。</strong></p>
<p>我们日常开发中会在什么时候用到此模式呢？</p>
<ol>
<li>几个类的主要逻辑相同，只在部分逻辑的算法和行为上稍有区别的情况</li>
<li>有几种相似的行为或算法，需要动态地决定使用哪一种</li>
</ol>
<p>具体如何使用策略模式，让我们举个《Head First 设计模式》中的例子:</p></div><a href="/2018/01/04/策略模式/" class="read-more">READ MORE</a></article></div><div class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/12/31/Java源码分析之Object类/" class="post-title-link">Java源码分析之Object类</a></h2><div class="post-info">Dec 31, 2017</div><div class="post-content"><p>最近在研究java常见类的源码，夯实一下基础。今天先总结一下Object类。</p>
<p>Object类是java中所有类的基类，位于java.lang包中。而java.lang包又是java中最基础最核心的包，无需手动导入，编译时自动导入。</p>
<h3 id="Native方法"><a href="#Native方法" class="headerlink" title="Native方法"></a>Native方法</h3><p>在讲Object之前，先来补充一下知识点，什么是Native方法。</p>
<p>“A native method is a Java method whose implementation is provided by non-java code.”</p>
<p>简单来说就是：<strong>一个native方法是由非java语言来实现的java方法</strong>。 </p>
<p>通常情况下在定义一个native方法时，不去提供实体类，因为实体类由非java语言在外面已经实现。所以这也意味着<strong>native不能与abstract方法连用</strong>。那为什么要用Native呢，当然是因为某些高效率任务用java不易实现，而像C/C++这样的语言相对来说容易些。</p>
<hr>
<p>Object类里面没有定义属性，里面只包含13种方法。</p>
<h3 id="registerNatives"><a href="#registerNatives" class="headerlink" title="registerNatives()"></a>registerNatives()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  registerNatives();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>registerNatives()被native修饰，意味着此方法并不是在Java中实现的。</p>
<p>简单来说registerNatives()的作用是将非java语言实现的方法与java中的native方法一一对应起来，就像英文名Zhang San和中文名张三匹配起来一样。</p>
<p>下面的static方法块的作用就是这个类在被类加载器加载时执行一次，且仅执行一次。</p></div><a href="/2017/12/31/Java源码分析之Object类/" class="read-more">READ MORE</a></article></div></div></div><div id="sidebar" class="left"><div id="about-panel"><div class="info"><div class="title">Liu Yong</div><div class="url">https://liuyong.cc</div><div class="bio">我想出门晒太阳</div></div><img src="/images/avatar.png" class="avatar"></div><div id="friend-links-panel"><div class="panel-title"><p>LINKS</p></div><a href="https://liuyong.cc/book-list" target="_blank" class="link-item"><div class="link-container"><div class="site-name">书单</div><div class="site-desc">https://liuyong.cc/bookList</div></div></a><a href="https://liuyong.cc/about" target="_blank" class="link-item"><div class="link-container"><div class="site-name">关于我</div><div class="site-desc">https://liuyong.cc/about</div></div></a></div></div></div><div class="clear"></div></main><footer class="footer-container"><div class="paginator"><a href="/" class="prev">PREV</a><a href="/page/3/" class="next">NEXT</a></div><div class="copyright"><p>© 2017 - 2019 <a href="https://liuyong.cc">Liu Yong</a> , Powered By <a href="https://hexo.io/" target="_blank">Hexo</a>.</p></div></footer></body></html>